// 全局变量
let bookmarks = [];
let categories = {};
let apiStatus = false;
let processingBatch = false;
let currentBatchIndex = 0;
let batchSize = 50;
let totalBookmarksCount = 0;
let logVisible = false;
const MAX_LOG_ENTRIES = 500; // 最大日志条目数
let bookmarkWorker = null; // Web Worker引用

// 书签管理器相关变量
let bookmarkTreeData = [];
let selectedBookmarks = new Set();
let currentEditingItem = null;
let draggedElement = null; // 拖拽元素
let inlineEditingElement = null; // 内联编辑元素
let batchEditMode = false; // 批量编辑模式

// 初始化分析页面
document.addEventListener('DOMContentLoaded', () => {
  // 初始化Web Worker
  initializeWorker();
  
  // 获取API状态
  checkApiStatus();
  
  // 添加按钮事件监听
  document.getElementById('analyze-bookmarks').addEventListener('click', analyzeBookmarks);
  document.getElementById('cancel-analyze').addEventListener('click', cancelAnalyze);
  document.getElementById('organize-bookmarks').addEventListener('click', organizeBookmarks);
  document.getElementById('export-bookmarks').addEventListener('click', exportBookmarks);
  document.getElementById('setup-api').addEventListener('click', openOptions);
  document.getElementById('view-history').addEventListener('click', openHistoryPage);
  
  // 添加新功能的事件监听器
  document.getElementById('detect-duplicates').addEventListener('click', detectDuplicateBookmarks);
  document.getElementById('detect-invalid').addEventListener('click', detectInvalidBookmarks);
  document.getElementById('cleanup-bookmarks').addEventListener('click', cleanupBookmarks);
  document.getElementById('manage-bookmarks').addEventListener('click', openBookmarkManager);
  document.getElementById('import-bookmarks').addEventListener('click', importBookmarks);
  document.getElementById('backup-bookmarks').addEventListener('click', backupBookmarks);
  
  // 书签管理器相关事件监听器
  document.getElementById('expand-all-folders').addEventListener('click', () => expandAllFolders(true));
  document.getElementById('collapse-all-folders').addEventListener('click', () => expandAllFolders(false));
  document.getElementById('create-folder').addEventListener('click', createNewFolder);
  document.getElementById('refresh-manager').addEventListener('click', refreshBookmarkManager);
  
  // 批量操作事件监听器
  document.getElementById('batch-delete').addEventListener('click', batchDeleteItems);
  document.getElementById('batch-move').addEventListener('click', batchMoveItems);
  document.getElementById('batch-export').addEventListener('click', batchExportItems);
  document.getElementById('select-all-bookmarks').addEventListener('click', () => selectAllBookmarks(true));
  document.getElementById('deselect-all-bookmarks').addEventListener('click', () => selectAllBookmarks(false));
  
  // 添加新的批量操作事件监听器
  document.getElementById('batch-rename').addEventListener('click', toggleBatchRenameMode);
  document.getElementById('save-batch-rename').addEventListener('click', saveBatchRenames);
  document.getElementById('cancel-batch-rename').addEventListener('click', cancelBatchRename);
  
  // 模态框事件监听器
  document.getElementById('modal-close').addEventListener('click', closeEditModal);
  document.getElementById('cancel-edit').addEventListener('click', closeEditModal);
  document.getElementById('save-edit').addEventListener('click', saveBookmarkEdit);
  document.getElementById('move-modal-close').addEventListener('click', closeMoveModal);
  document.getElementById('cancel-move').addEventListener('click', closeMoveModal);
  document.getElementById('confirm-move').addEventListener('click', confirmMoveItems);
  
  // 检测结果操作事件监听器
  document.getElementById('remove-duplicates').addEventListener('click', removeDuplicateBookmarks);
  document.getElementById('remove-invalid').addEventListener('click', removeInvalidBookmarks);
  document.getElementById('remove-empty-folders').addEventListener('click', removeEmptyFolders);
  document.getElementById('select-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', true));
  document.getElementById('deselect-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', false));
  document.getElementById('select-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', true));
  document.getElementById('deselect-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', false));
  document.getElementById('select-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', true));
  document.getElementById('deselect-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', false));
  
  // 文件导入事件监听器
  document.getElementById('bookmark-file-input').addEventListener('change', handleFileImport);
  
  // 添加日志控制按钮事件监听
  document.getElementById('toggle-log').addEventListener('click', toggleLogVisibility);
  document.getElementById('clear-log').addEventListener('click', clearLog);
  
  // 添加可视化切换事件
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.addEventListener('click', switchVisualizationTab);
  });
  
  // 添加窗口关闭事件，终止Worker
  window.addEventListener('beforeunload', terminateWorker);
});

// 初始化Web Worker
function initializeWorker() {
  try {
    // 确保之前的worker已终止
    if (bookmarkWorker) {
      bookmarkWorker.terminate();
    }
    
    // 创建新Worker
    bookmarkWorker = new Worker('bookmarkProcessor.js');
    
    // 设置消息处理
    bookmarkWorker.onmessage = handleWorkerMessage;
    bookmarkWorker.onerror = handleWorkerError;
    
    addLogEntry('Web Worker初始化成功 - 启用后台处理以提高性能', 'success');
  } catch (error) {
    console.error('无法初始化Web Worker:', error);
    addLogEntry('无法初始化Web Worker, 将使用主线程处理 - ' + error.message, 'warning');
  }
}

// 处理Worker消息
function handleWorkerMessage(e) {
  const { action, ...data } = e.data;
  
  switch (action) {
    case 'process-bookmarks-result':
      console.log('收到Worker处理的书签数据', data.processedBookmarks.length);
      // 处理Worker返回的预处理书签数据
      break;
      
    case 'merge-categories-result':
      categories = data.mergedCategories;
      console.log('分类已在Worker中合并', Object.keys(categories).length);
      displayCategories(categories, 20);
      break;
      
    case 'error':
      console.error('Worker错误:', data.error);
      addLogEntry(`Worker处理出错: ${data.error}`, 'error');
      break;
      
    default:
      console.log('未处理的Worker消息:', action, data);
  }
}

// 处理Worker错误
function handleWorkerError(error) {
  console.error('Worker运行错误:', error);
  addLogEntry(`Worker运行错误: ${error.message}`, 'error');
}

// 终止Worker
function terminateWorker() {
  if (bookmarkWorker) {
    bookmarkWorker.terminate();
    bookmarkWorker = null;
  }
}

// 切换日志可见性
function toggleLogVisibility() {
  const logContainer = document.getElementById('log-container');
  logVisible = !logVisible;
  
  if (logVisible) {
    logContainer.classList.remove('hidden');
  } else {
    logContainer.classList.add('hidden');
  }
}

// 清空日志
function clearLog() {
  document.getElementById('log-entries').innerHTML = '';
}

// 添加日志条目
function addLogEntry(message, type = 'info') {
  const logContainer = document.getElementById('log-entries');
  
  // 限制日志条目数量，避免内存占用过大
  const entries = logContainer.querySelectorAll('.log-entry');
  if (entries.length >= MAX_LOG_ENTRIES) {
    // 移除最早的20%日志条目
    const removeCount = Math.ceil(MAX_LOG_ENTRIES * 0.2);
    for (let i = 0; i < removeCount; i++) {
      if (logContainer.firstChild) {
        logContainer.removeChild(logContainer.firstChild);
      }
    }
    // 添加一条提示信息
    if (logContainer.firstChild === logContainer.querySelector('.log-entry-trimmed')) {
      // 已经有提示，不重复添加
    } else {
      const trimNotice = document.createElement('div');
      trimNotice.className = 'log-entry log-entry-trimmed warning';
      trimNotice.textContent = `为提高性能，已移除 ${removeCount} 条较早的日志...`;
      logContainer.insertBefore(trimNotice, logContainer.firstChild);
    }
  }
  
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  
  // 添加时间戳
  const timeStamp = new Date().toLocaleTimeString();
  const timeSpan = document.createElement('span');
  timeSpan.className = 'log-entry-time';
  timeSpan.textContent = `[${timeStamp}]`;
  
  entry.appendChild(timeSpan);
  entry.appendChild(document.createTextNode(` ${message}`));
  
  // 添加到日志容器
  logContainer.appendChild(entry);
  
  // 自动滚动到底部
  logContainer.scrollTop = logContainer.scrollHeight;
  
  // 如果日志不可见且是重要信息，自动显示
  if (!logVisible && (type === 'error' || type === 'warning')) {
    toggleLogVisibility();
  }
  
  // 同时在控制台记录
  console.log(`[${type}] ${message}`);
}

// 检查API连接状态
function checkApiStatus() {
  chrome.storage.sync.get(['apiProvider', 'apiKey'], (result) => {
    const apiStatusElement = document.getElementById('api-status');
    
    if (result.apiProvider && result.apiKey) {
      apiStatus = true;
      apiStatusElement.textContent = '已连接';
      apiStatusElement.className = 'api-connected';
      addLogEntry(`API状态：已连接 (提供商: ${result.apiProvider})`, 'success');
    } else {
      apiStatus = false;
      apiStatusElement.textContent = '未连接';
      apiStatusElement.className = 'api-not-connected';
      addLogEntry('API状态：未连接，请先在设置中配置API', 'warning');
    }
  });
}

// 打开选项页面
function openOptions() {
  chrome.runtime.openOptionsPage();
}

// 分析书签
async function analyzeBookmarks() {
  if (!apiStatus) {
    showStatus('请先在设置中配置API连接', 'error');
    addLogEntry('API未连接，请先在设置中配置API连接', 'error');
    return;
  }
  
  // 清空之前的日志
  clearLog();
  
  // 显示加载动画和进度条
  showLoading(true);
  showProgress(true);
  showStatus('正在获取书签...');
  addLogEntry('开始书签分析过程...', 'info');
  
  // 显示取消按钮，隐藏分析按钮
  toggleAnalyzeButtons(true);
  
  try {
    // 重置状态
    categories = {};
    currentBatchIndex = 0;
    processingBatch = false;
    
    // 获取所有书签
    addLogEntry('正在获取所有书签...', 'info');
    bookmarks = await getAllBookmarks();
    totalBookmarksCount = bookmarks.length;
    
    // 添加标签层级统计
    addLogEntry('开始分析书签结构...', 'info');
    const folderStructure = {};
    
    bookmarks.forEach(bookmark => {
      if (bookmark.parentId) {
        folderStructure[bookmark.parentId] = folderStructure[bookmark.parentId] || [];
        folderStructure[bookmark.parentId].push(bookmark.id);
      }
    });
    
    // 统计书签所在的文件夹分布
    const folderDistribution = Object.entries(folderStructure)
      .map(([folderId, bookmarkIds]) => ({
        folderId,
        count: bookmarkIds.length
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
    
    addLogEntry('书签文件夹分布(TOP5):', 'info');
    folderDistribution.forEach(folder => {
      addLogEntry(`  - 文件夹ID ${folder.folderId}: 包含${folder.count}个书签`, 'info');
    });
    
    addLogEntry(`成功获取 ${totalBookmarksCount} 个书签`, 'success');
    showStatus(`已获取 ${totalBookmarksCount} 个书签，正在分批分析...`);
    
    // 获取API设置和批处理大小
    addLogEntry('正在获取API设置...', 'info');
    const settings = await getApiSettings();
    batchSize = settings.batchSize;
    
    addLogEntry(`API提供商: ${settings.provider}, 模型: ${settings.model}`, 'info');
    addLogEntry(`批处理大小: ${batchSize}`, 'info');
    
    // 开始批处理
    processingBatch = true;
    addLogEntry('开始批量处理书签...', 'info');
    await processBatches(settings);
    
  } catch (error) {
    console.error('分析书签时出错:', error);
    addLogEntry(`分析出错: ${error.message}`, 'error');
    showStatus(`分析出错: ${error.message}`, 'error');
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 取消分析
function cancelAnalyze() {
  processingBatch = false;
  addLogEntry('用户请求取消分析，正在中断处理...', 'warning');
  showStatus('正在取消分析...');
}

// 切换分析/取消按钮
function toggleAnalyzeButtons(isProcessing) {
  const analyzeButton = document.getElementById('analyze-bookmarks');
  const cancelButton = document.getElementById('cancel-analyze');
  
  if (isProcessing) {
    analyzeButton.classList.add('hidden');
    cancelButton.classList.remove('hidden');
  } else {
    analyzeButton.classList.remove('hidden');
    cancelButton.classList.add('hidden');
  }
}

// 更新进度条
function updateProgress(current, total) {
  const progressBar = document.getElementById('progress-bar');
  const percentage = Math.min(Math.round((current / total) * 100), 100);
  progressBar.style.width = `${percentage}%`;
}

// 批量处理书签
async function processBatches(settings) {
  try {
    const totalBatches = Math.ceil(bookmarks.length / batchSize);
    addLogEntry(`总共将分成 ${totalBatches} 个批次处理`, 'info');
    
    // 记录内存使用情况
    if (window.performance && window.performance.memory) {
      const memoryInfo = window.performance.memory;
      addLogEntry(`初始内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`, 'info');
    }
    
    while (currentBatchIndex < totalBatches && processingBatch) {
      const startIdx = currentBatchIndex * batchSize;
      const endIdx = Math.min(startIdx + batchSize, bookmarks.length);
      const currentBatch = bookmarks.slice(startIdx, endIdx);
      
      // 更新进度条
      updateProgress(startIdx, bookmarks.length);
      
      const batchInfo = `批次 ${currentBatchIndex + 1}/${totalBatches} (${startIdx + 1}-${endIdx}/${totalBookmarksCount})`;
      showStatus(`正在处理第 ${currentBatchIndex + 1}/${totalBatches} 批书签 (${startIdx + 1}-${endIdx}/${totalBookmarksCount})...`);
      addLogEntry(`开始处理${batchInfo}`, 'info');
      
      // 等待一小段时间让UI更新
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // 分类当前批次的书签
      addLogEntry(`正在调用API对${batchInfo}进行分类...`, 'info');
      const startTime = Date.now();
      
      // 使用try-catch单独处理每批，避免一批失败影响整体
      try {
        const batchCategories = await categorizeBookmarks(currentBatch, settings);
        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        // 记录分类结果
        const categoryCount = Object.keys(batchCategories).length;
        addLogEntry(`${batchInfo}分类完成，用时${elapsedTime}秒，分为${categoryCount}个类别`, 'success');
        
        // 打印每个类别的书签数量（仅打印前10个类别，避免日志过多）
        const categoriesToLog = Object.entries(batchCategories).slice(0, 10);
        categoriesToLog.forEach(([category, items]) => {
          addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
        });
        
        if (Object.keys(batchCategories).length > 10) {
          addLogEntry(`  - ... 以及 ${Object.keys(batchCategories).length - 10} 个其他类别`, 'info');
        }
        
        // 合并分类结果
        addLogEntry(`正在合并${batchInfo}分类结果...`, 'info');
        mergeCategoryResults(batchCategories);
        
      } catch (batchError) {
        addLogEntry(`处理${batchInfo}时出错: ${batchError.message}，跳过此批次`, 'error');
        console.error(`批次处理错误:`, batchError);
      }
      
      // 批次处理完成后，等待一段时间让UI刷新，防止浏览器卡死
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 限制显示类别数量，避免DOM过度膨胀
      displayCategories(categories, 20);
      
      // 每处理3批，手动触发垃圾回收并清理不再需要的数据
      if (currentBatchIndex % 3 === 0) {
        addLogEntry('执行内存优化...', 'info');
        
        // 清除当前批次的临时变量
        const currentBatch = null;
        
        // 在后台任务中执行昂贵的清理操作
        setTimeout(() => {
          // 提示浏览器进行垃圾回收
          if (window.gc) {
            try {
              window.gc();
            } catch (e) {
              // 忽略，某些浏览器不支持手动垃圾回收
            }
          }
          
          // 记录内存使用情况
          if (window.performance && window.performance.memory) {
            const memoryInfo = window.performance.memory;
            console.log(`当前内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`);
          }
        }, 0);
      }
      
      // 更新进度
      currentBatchIndex++;
    }
    
    // 更新到100%
    updateProgress(bookmarks.length, bookmarks.length);
    
    if (processingBatch) {
      // 全部处理完成
      const finalCategories = Object.keys(categories).length;
      showStatus(`分析完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      addLogEntry(`分析全部完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      
      // 保存分析历史版本
      await saveBookmarkHistory();
      
      // 生成可视化图表
      generateVisualizations();
      
      // 释放内存
      setTimeout(() => {
        addLogEntry('正在优化内存使用...', 'info');
        // 仅保留必要数据
        bookmarks = bookmarks.map(bookmark => ({
          id: bookmark.id,
          title: bookmark.title,
          url: bookmark.url,
          parentId: bookmark.parentId
        }));
        
        // 提示浏览器进行垃圾回收
        if (window.gc) {
          try {
            window.gc();
          } catch (e) {
            // 忽略
          }
        }
      }, 1000);
      
      // 显示最终分类统计（限制数量）
      const topCategories = Object.entries(categories)
        .sort((a, b) => b[1].length - a[1].length)
        .slice(0, 20);
      
      topCategories.forEach(([category, items]) => {
        addLogEntry(`${category}: ${items.length}个书签`, 'success');
      });
      
      if (Object.keys(categories).length > 20) {
        addLogEntry(`... 以及 ${Object.keys(categories).length - 20} 个其他类别`, 'success');
      }
      
      // 完成后显示全部分类
      displayCategories(categories);
    } else {
      // 用户取消了处理
      showStatus('书签分析已中断', 'error');
      addLogEntry('书签分析被用户中断', 'warning');
    }
  } catch (error) {
    console.error('批处理书签时出错:', error);
    showStatus(`批处理出错: ${error.message}`, 'error');
    addLogEntry(`批处理出错: ${error.message}`, 'error');
  } finally {
    processingBatch = false;
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 使用Worker合并分类结果
function mergeCategoryResults(batchCategories) {
  // 检查Worker是否可用
  if (bookmarkWorker) {
    try {
      // 通过Worker合并分类
      bookmarkWorker.postMessage({
        action: 'merge-categories',
        data: {
          existingCategories: categories,
          newCategories: batchCategories
        }
      });
      return; // Worker会异步更新categories
    } catch (error) {
      console.error('Worker合并分类失败，回退到主线程:', error);
      addLogEntry('Worker处理失败，切换至主线程', 'warning');
    }
  }
  
  // 回退到主线程处理
  for (const [category, items] of Object.entries(batchCategories)) {
    if (!categories[category]) {
      categories[category] = [];
    }
    
    categories[category] = categories[category].concat(items);
  }
}

// 获取所有书签
function getAllBookmarks() {
  return new Promise((resolve) => {
    chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      const bookmarks = [];
      
      // 添加调试信息
      addLogEntry(`开始获取书签树...`, 'info');
      console.log('书签树根节点:', bookmarkTreeNodes);
      
      // 递归函数，遍历书签树
      function processNode(node) {
        // 如果是书签（有url属性）
        if (node.url) {
          // 记录原始书签数据，用于调试
          console.log('处理书签:', { id: node.id, title: node.title, url: node.url });
          
          // 添加标签信息到日志
          addLogEntry(`获取书签: ID=${node.id}, 标题="${node.title}", URL=${node.url.substring(0, 30)}...`, 'info');
          
          // 验证并处理标题
          let processedTitle = node.title || '';
          // 如果标题为空或只包含数字，尝试从URL生成更有意义的标题
          if (!processedTitle || /^\d+$/.test(processedTitle)) {
            try {
              const url = new URL(node.url);
              // 使用主机名作为标题的一部分
              processedTitle = url.hostname.replace(/^www\./, '');
              addLogEntry(`发现无效书签标题(${node.title})，已自动替换为: ${processedTitle}`, 'warning');
            } catch (e) {
              // URL解析失败，保留原标题
              processedTitle = node.title || '未命名书签';
            }
          }
          
          bookmarks.push({
            id: node.id,
            title: processedTitle,
            url: node.url,
            parentId: node.parentId,
            originalTitle: node.title // 保存原始标题以便比较
          });
        }
        
        // 如果是文件夹，记录文件夹信息
        if (!node.url && node.title) {
          addLogEntry(`发现书签文件夹: ID=${node.id}, 标题="${node.title}"`, 'info');
        }
        
        // 如果有子节点，继续处理
        if (node.children) {
          addLogEntry(`处理文件夹"${node.title || '根目录'}"的${node.children.length}个子项`, 'info');
          for (const child of node.children) {
            processNode(child);
          }
        }
      }
      
      // 从根节点开始处理
      for (const node of bookmarkTreeNodes) {
        processNode(node);
      }
      
      // 添加调试信息
      const emptyTitles = bookmarks.filter(b => !b.title).length;
      const numericTitles = bookmarks.filter(b => /^\d+$/.test(b.title)).length;
      addLogEntry(`书签获取完成: 总计${bookmarks.length}个书签, ${emptyTitles}个空标题, ${numericTitles}个纯数字标题`, 'info');
      
      // 添加更详细的分类统计
      const domainMap = {};
      bookmarks.forEach(bookmark => {
        try {
          const url = new URL(bookmark.url);
          const domain = url.hostname.replace(/^www\./, '');
          domainMap[domain] = (domainMap[domain] || 0) + 1;
        } catch (e) {
          // 忽略无效URL
        }
      });
      
      // 输出前10个最常见的域名
      const topDomains = Object.entries(domainMap)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (topDomains.length > 0) {
        addLogEntry(`最常见的域名:`, 'info');
        topDomains.forEach(([domain, count]) => {
          addLogEntry(`  - ${domain}: ${count}个书签`, 'info');
        });
      }
      
      resolve(bookmarks);
    });
  });
}

// 获取API设置
function getApiSettings() {
  return new Promise((resolve) => {
    chrome.storage.sync.get([
      'apiProvider', 
      'apiKey', 
      'customApiUrl', 
      'geminiModel', 
      'openaiModel', 
      'customModel', 
      'defaultCategories', 
      'batchSize'
    ], (result) => {
      const apiProvider = result.apiProvider || 'gemini';
      let model = '';
      
      // 根据提供商选择对应的模型
      switch (apiProvider) {
        case 'gemini':
          model = result.geminiModel || 'gemini-2.0-flash';
          break;
        case 'openai':
          model = result.openaiModel || 'gpt-3.5-turbo';
          break;
        case 'custom':
          model = result.customModel || '';
          break;
      }
      
      resolve({
        provider: apiProvider,
        apiKey: result.apiKey || '',
        customApiUrl: result.customApiUrl || '',
        model: model,
        defaultCategories: result.defaultCategories || '技术,教育,购物,社交媒体,新闻,娱乐,工作,其他',
        batchSize: result.batchSize || 50
      });
    });
  });
}

// 使用AI对书签进行分类
async function categorizeBookmarks(bookmarks, settings) {
  // 增强预处理：检查并修复书签数据
  addLogEntry(`开始预处理书签数据...`, 'info');
  
  // 统计有效书签数量
  const validBookmarks = bookmarks.filter(b => b.title && b.url).length;
  const totalBookmarks = bookmarks.length;
  if (validBookmarks < totalBookmarks) {
    addLogEntry(`警告: 检测到${totalBookmarks - validBookmarks}个无效书签 (无标题或URL)`, 'warning');
  }
  
  // 标签长度统计
  const titleLengths = bookmarks.map(b => b.title ? b.title.length : 0);
  const avgTitleLength = titleLengths.reduce((sum, len) => sum + len, 0) / titleLengths.length || 0;
  const maxTitleLength = Math.max(...titleLengths);
  const minTitleLength = Math.min(...(titleLengths.filter(len => len > 0) || [0]));
  
  addLogEntry(`标签标题统计: 平均长度=${avgTitleLength.toFixed(1)}字符, 最长=${maxTitleLength}字符, 最短=${minTitleLength}字符`, 'info');
  
  // 检查常见的特殊标签
  const specialPatterns = {
    '纯数字标题': /^\d+$/,
    '包含特殊字符': /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/,
    '非中文标题': /^[^\u4e00-\u9fa5]+$/,
    '过长标题(>30字符)': title => title.length > 30
  };
  
  const specialStats = {};
  Object.keys(specialPatterns).forEach(key => {
    specialStats[key] = 0;
  });
  
  bookmarks.forEach(bookmark => {
    if (bookmark.title) {
      Object.entries(specialPatterns).forEach(([key, pattern]) => {
        if (typeof pattern === 'function') {
          if (pattern(bookmark.title)) specialStats[key]++;
        } else if (pattern.test(bookmark.title)) {
          specialStats[key]++;
        }
      });
    }
  });
  
  addLogEntry(`标签特征统计:`, 'info');
  Object.entries(specialStats).forEach(([key, count]) => {
    const percentage = ((count / totalBookmarks) * 100).toFixed(1);
    addLogEntry(`  - ${key}: ${count}个 (${percentage}%)`, 'info');
  });
  
  // 预处理：创建更友好的数据集
  const bookmarkData = bookmarks.map(b => {
    // 尝试从URL提取域名作为附加信息
    let domain = '';
    try {
      if (b.url) {
        const urlObj = new URL(b.url);
        domain = urlObj.hostname.replace(/^www\./, '');
      }
    } catch (e) {
      // URL解析失败，忽略
    }
    
    return {
      title: b.title || domain || '未命名书签',
      url: b.url || '',
      domain: domain
    };
  });
  
  // 简单自动分类：尝试预先识别一些常见类别
  const preCategorized = {};
  const domainPatterns = {
    // AI工具和服务
    '通用AI工具': [/gemini\.google\.com/, /openai\.com/, /chat\.openai\.com/, /perplexity\.ai/, /claude\.ai/, /poe\.com/],
    'AI开发平台': [/aistudio\.google\.com/, /platform\.openai\.com/, /colab\.research\.google/, /huggingface\.co/],
    'AI笔记工具': [/notebooklm\.google\.com/, /notion\.ai/, /obsidian\.md/],
    
    // 设计工具和平台
    'UI设计工具': [/figma\.com/, /sketch\.com/, /adobe\.com/, /canva\.com/, /framer\.com/],
    '原型设计': [/gamma\.app/, /miro\.com/, /whimsical\.com/, /mockplus\.com/, /axure\.com/],
    '开发设计工具': [/lovable\.dev/, /v0\.dev/, /bolt\.new/, /replit\.com/, /codesandbox\.io/],
    
    // 教程和学习资源
    'UI设计教程': [/uisdc\.com/, /uxdesign\.cc/, /dribbble\.com/, /behance\.net/, /designbetter\.co/],
    '技术教程': [/csdn\.net/, /juejin\.cn/, /segmentfault\.com/, /dev\.to/, /medium\.com/],
    '在线课程': [/coursera\.org/, /udemy\.com/, /edx\.org/, /khan.*academy/, /freecodecamp\.org/],
    
    // 开发工具
    '代码托管': [/github\.com/, /gitlab\.com/, /gitee\.com/, /bitbucket\.org/],
    '技术问答': [/stackoverflow\.com/, /stackexchange\.com/, /zhihu\.com/],
    '文档工具': [/gitbook\.com/, /docsify\.js\.org/, /vuepress\.vuejs\.org/],
    
    // 实用工具
    '翻译工具': [/translate\.google\.com/, /deepl\.com/, /fanyi\.baidu\.com/, /youdao\.com/],
    '图片工具': [/tinypng\.com/, /remove\.bg/, /unsplash\.com/, /pexels\.com/],
    '在线办公': [/docs\.google\.com/, /office\.com/, /notion\.so/, /airtable\.com/],
    
    // 传统分类（保留但细化）
    '视频娱乐': [/youtube\.com/, /bilibili\.com/, /netflix\.com/, /youku\.com/, /iqiyi\.com/],
    '社交媒体': [/twitter\.com/, /facebook\.com/, /instagram\.com/, /weibo\.com/, /linkedin\.com/, /reddit\.com/],
    '电商购物': [/taobao\.com/, /jd\.com/, /amazon\.com/, /tmall\.com/, /pinduoduo\.com/],
    '邮箱服务': [/mail\./, /gmail\.com/, /outlook\.com/, /qq\.com.*mail/],
    '新闻资讯': [/news\./, /sina\.com/, /qq\.com/, /163\.com/, /bbc\./, /cnn\./]
  };
  
  // 基于书签标题的关键词匹配（增强识别能力）
  const titleKeywords = {
    'AI工具教程': ['AI教程', 'ChatGPT教程', 'Gemini使用', '人工智能教程', 'AI学习', 'machine learning'],
    'UI设计素材': ['设计素材', 'UI素材', '图标', 'icon', '配色', 'color', '字体', 'font'],
    'UI设计案例': ['设计案例', 'UI案例', '界面设计', '交互设计', 'UX案例', '设计灵感'],
    'Figma教程': ['Figma', 'figma教程', '组件库', 'design system'],
    '游戏UI设计': ['游戏UI', '游戏界面', 'game ui', 'game design'],
    '前端开发': ['前端', 'frontend', 'Vue', 'React', 'Angular', 'JavaScript'],
    '后端开发': ['后端', 'backend', 'API', 'Node.js', 'Python', 'Java'],
    '移动开发': ['移动开发', 'iOS', 'Android', 'Flutter', 'React Native']
  };
  
  // 尝试做一些预分类，帮助AI更好理解
  bookmarkData.forEach(bookmark => {
    let categorized = false;
    
    // 首先尝试域名匹配
    for (const [category, patterns] of Object.entries(domainPatterns)) {
      if (patterns.some(pattern => pattern.test(bookmark.domain || bookmark.url))) {
        if (!preCategorized[category]) {
          preCategorized[category] = [];
        }
        preCategorized[category].push(bookmark);
        categorized = true;
        break; // 一个书签只归入一个预分类
      }
    }
    
    // 如果域名没有匹配到，尝试标题关键词匹配
    if (!categorized && bookmark.title) {
      const title = bookmark.title.toLowerCase();
      for (const [category, keywords] of Object.entries(titleKeywords)) {
        if (keywords.some(keyword => title.includes(keyword.toLowerCase()))) {
          if (!preCategorized[category]) {
            preCategorized[category] = [];
          }
          preCategorized[category].push(bookmark);
          break;
        }
      }
    }
  });
  
  // 输出预分类结果
  addLogEntry(`预分类结果:`, 'info');
  Object.entries(preCategorized).forEach(([category, items]) => {
    addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
  });
  
  // 统计未被预分类的书签数量
  const preCategorizedCount = Object.values(preCategorized).reduce((sum, items) => sum + items.length, 0);
  const uncategorizedCount = bookmarkData.length - preCategorizedCount;
  addLogEntry(`预分类统计: 已分类${preCategorizedCount}个 (${((preCategorizedCount/bookmarkData.length)*100).toFixed(1)}%), 未分类${uncategorizedCount}个`, 'info');
  
  // 添加预分类信息到提示词中，帮助AI更好地理解
  const preCategorizedInfo = Object.entries(preCategorized)
    .map(([category, items]) => `- ${category}: ${items.length}个书签，例如: ${items.slice(0, 3).map(b => b.title).join(', ')}...`)
    .join('\n');
  
  // 构建提示词
  const prompt = `你是一个专业的书签分类助手。请对以下书签进行详细分类，创建有意义且细致的分类体系。

分类指导原则：
1. 分类数量：鼓励创建10-25个细分类别，根据书签内容的丰富程度灵活调整
2. 分类细度：优先创建细致、专业的分类，而不是宽泛的大类
3. 分类名称：使用准确、专业的中文词汇，体现具体用途或领域
4. 禁止使用：数字(0,1,2...)、字母(A,B,C...)或特殊符号作为分类名
5. 输出格式：严格JSON格式，不添加其他说明文字

建议的细分类别示例（根据实际内容调整）：
- AI工具类：通用AI工具、AI开发平台、AI笔记工具、AI工具教程
- 设计类：UI设计工具、原型设计、UI设计教程、UI设计素材、设计案例、Figma教程
- 开发类：代码托管、技术教程、前端开发、后端开发、技术问答
- 实用工具：翻译工具、图片工具、在线办公
- 学习资源：在线课程、技术文档、设计学习

${preCategorizedInfo ? `参考预分类（可进一步细分或调整）：\n${preCategorizedInfo}\n` : ''}

请根据书签的具体内容和用途，创建尽可能准确和细致的分类：

输出格式：
{
  "通用AI工具": [
    {"title": "Gemini", "url": "https://gemini.google.com/app"},
    {"title": "Perplexity", "url": "https://www.perplexity.ai/"}
  ],
  "AI开发平台": [
    {"title": "Google AI Studio", "url": "https://aistudio.google.com/"}
  ],
  "UI设计教程": [
    {"title": "Figma组件库教程", "url": "https://www.uisdc.com/..."}
  ]
}

需要分类的书签：
${JSON.stringify(bookmarkData, null, 2)}`;

  // 根据API提供商选择合适的处理方法
  let categoryResult;
  try {
    addLogEntry(`开始调用AI进行书签分类...`, 'info');
    
    switch (settings.provider) {
      case 'gemini':
        categoryResult = await callGeminiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'openai':
        categoryResult = await callOpenAiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'custom':
        categoryResult = await callCustomApi(settings.apiKey, settings.customApiUrl, settings.model, prompt);
        break;
      default:
        throw new Error('不支持的API提供商');
    }
    
    addLogEntry(`AI分类完成，获得${Object.keys(categoryResult).length}个分类`, 'success');
    
    // 分析分类质量
    const categoryNames = Object.keys(categoryResult);
    const numericCategories = categoryNames.filter(name => /^\d+$/.test(name)).length;
    const shortCategories = categoryNames.filter(name => name.length < 2).length;
    const longCategories = categoryNames.filter(name => name.length > 10).length;
    
    addLogEntry(`分类质量分析:`, 'info');
    addLogEntry(`  - 纯数字分类: ${numericCategories}个`, numericCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过短分类(小于2字符): ${shortCategories}个`, shortCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过长分类(大于10字符): ${longCategories}个`, longCategories > 0 ? 'info' : 'info');
    
    // 如果API返回空结果或没有分类，尝试使用预分类结果
    if (!categoryResult || Object.keys(categoryResult).length === 0) {
      addLogEntry('API返回的分类结果为空，尝试使用预分类结果', 'warning');
      
      if (Object.keys(preCategorized).length > 0) {
        categoryResult = preCategorized;
        addLogEntry(`使用预分类结果: ${Object.keys(preCategorized).length}个分类`, 'info');
      } else {
        // 创建一个基本分类
        categoryResult = { "未分类": bookmarkData };
        addLogEntry(`无法获取有效分类，所有书签归为"未分类"`, 'error');
      }
    }
    
    // 验证并优化分类结果
    return validateAndOptimizeCategories(categoryResult, bookmarks.length);
  } catch (error) {
    console.error('分类处理失败:', error);
    addLogEntry(`分类处理失败: ${error.message}，尝试使用备用方案`, 'error');
    
    // 出错时使用预分类作为备用方案
    if (Object.keys(preCategorized).length > 0) {
      // 将未预分类的书签放入"其他"分类
      const uncategorized = bookmarkData.filter(bookmark => {
        return !Object.values(preCategorized).some(items => 
          items.some(item => item.url === bookmark.url)
        );
      });
      
      if (uncategorized.length > 0) {
        preCategorized["其他"] = uncategorized;
      }
      
      addLogEntry(`使用预分类作为备用方案: ${Object.keys(preCategorized).length}个分类`, 'info');
      return preCategorized;
    }
    
    // 如果没有预分类，使用基本分类
    const basicCategories = {
      "常用网站": bookmarkData.slice(0, Math.min(20, bookmarkData.length)),
      "其他书签": bookmarkData.slice(Math.min(20, bookmarkData.length))
    };
    
    addLogEntry(`无法进行分类，使用基本分类方案`, 'warning');
    return basicCategories;
  }
}

// 验证并优化分类结果
function validateAndOptimizeCategories(categories, totalBookmarks) {
  // 提高分类数量限制，鼓励细分
  const MAX_CATEGORIES = 30; // 从20提高到30
  let categoriesCount = Object.keys(categories).length;
  
  // 只有在分类数量严重超标时才进行合并
  if (categoriesCount > MAX_CATEGORIES) {
    addLogEntry(`分类数量(${categoriesCount})超过最大限制(${MAX_CATEGORIES})，正在适度优化...`, 'warning');
    
    // 获取所有分类及其书签数量
    const categoriesWithCount = Object.entries(categories)
      .map(([name, items]) => ({ name, count: items.length }))
      .sort((a, b) => b.count - a.count);
    
    // 保留前25个分类，只合并极小的分类（少于等于1个书签的）
    const mainCategories = categoriesWithCount.slice(0, MAX_CATEGORIES - 5);
    const smallCategories = categoriesWithCount.slice(MAX_CATEGORIES - 5);
    
    // 只合并真正的小分类（1个书签的分类）
    const verySmallCategories = smallCategories.filter(cat => cat.count <= 1);
    const keepCategories = smallCategories.filter(cat => cat.count > 1);
    
    // 创建新的分类结果
    const optimizedCategories = {};
    
    // 添加主要分类
    mainCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 保留有意义的小分类（超过1个书签）
    keepCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 只合并极小的分类
    if (verySmallCategories.length > 0) {
      optimizedCategories["其他"] = optimizedCategories["其他"] || [];
      verySmallCategories.forEach(cat => {
        optimizedCategories["其他"] = optimizedCategories["其他"].concat(categories[cat.name]);
      });
      addLogEntry(`已将${verySmallCategories.length}个单书签分类合并到"其他"`, 'info');
    }
    
    return optimizedCategories;
  }
  
  // 验证分类名称，修复纯数字或无意义的分类名
  const optimizedCategories = {};
  const numericPattern = /^[\d]+$/;  // 匹配纯数字
  
  Object.entries(categories).forEach(([categoryName, items]) => {
    let newName = categoryName;
    
    // 检查是否为纯数字或太短的分类名
    if (numericPattern.test(categoryName) || categoryName.length < 2) {
      // 尝试根据内容推断更好的名称
      newName = inferCategoryName(items) || "其他";
      addLogEntry(`已修正无效的分类名"${categoryName}"为"${newName}"`, 'warning');
    }
    
    // 添加到优化后的分类
    if (!optimizedCategories[newName]) {
      optimizedCategories[newName] = [];
    }
    optimizedCategories[newName] = optimizedCategories[newName].concat(items);
  });
  
  addLogEntry(`分类验证完成，保留${Object.keys(optimizedCategories).length}个分类`, 'success');
  
  return optimizedCategories;
}

// 尝试根据书签内容推断分类名称
function inferCategoryName(bookmarks) {
  // 常见网站类型映射
  const domainCategories = {
    'github.com': '程序开发',
    'youtube.com': '视频娱乐',
    'bilibili.com': '视频娱乐',
    'zhihu.com': '问答社区',
    'taobao.com': '网上购物',
    'jd.com': '网上购物',
    'tmall.com': '网上购物',
    'weibo.com': '社交媒体',
    'twitter.com': '社交媒体',
    'facebook.com': '社交媒体',
    'instagram.com': '社交媒体',
    'linkedin.com': '职业社交',
    'stackoverflow.com': '技术问答',
    'mail.': '电子邮箱',
    'gmail': '电子邮箱',
    'outlook': '电子邮箱',
    'docs.google.com': '在线办公',
    'notion.so': '在线办公',
    'edu.': '教育学习',
    'csdn.net': '技术博客',
    'juejin.cn': '技术博客',
    'medium.com': '博客平台'
  };
  
  // 提取所有书签的域名
  const domains = bookmarks.map(bm => {
    try {
      if (!bm.url) return '';
      const urlObj = new URL(bm.url);
      return urlObj.hostname;
    } catch {
      return '';
    }
  }).filter(Boolean);
  
  // 尝试找出最常见的域名类型
  const categoryMatches = {};
  
  domains.forEach(domain => {
    for (const [pattern, category] of Object.entries(domainCategories)) {
      if (domain.includes(pattern)) {
        categoryMatches[category] = (categoryMatches[category] || 0) + 1;
      }
    }
  });
  
  // 找出匹配最多的分类
  let bestCategory = null;
  let maxMatches = 0;
  
  for (const [category, matches] of Object.entries(categoryMatches)) {
    if (matches > maxMatches) {
      maxMatches = matches;
      bestCategory = category;
    }
  }
  
  // 如果有超过20%的书签匹配同一个分类，使用该分类
  if (bestCategory && maxMatches >= domains.length * 0.2) {
    return bestCategory;
  }
  
  // 没有找到合适的分类
  return null;
}

// 共享的JSON解析和修复函数
function parseJsonWithRecovery(jsonStr) {
  // 首先尝试直接解析
  try {
    const result = JSON.parse(jsonStr);
    return result;
  } catch (firstError) {
    addLogEntry(`初次JSON解析失败: ${firstError.message}`, 'warning');
    
    // 尝试修复常见的JSON错误
    let fixedJson = jsonStr;
    
    // 修复1: 移除可能的前导/尾随文本
    const cleanMatch = fixedJson.match(/{[\s\S]*}/);
    if (cleanMatch) {
      fixedJson = cleanMatch[0];
    }
    
    // 修复2: 处理不完整的JSON（添加缺失的大括号或方括号）
    const openBraces = (fixedJson.match(/{/g) || []).length;
    const closeBraces = (fixedJson.match(/}/g) || []).length;
    const openBrackets = (fixedJson.match(/\[/g) || []).length;
    const closeBrackets = (fixedJson.match(/]/g) || []).length;
    
    // 添加缺失的闭合括号
    for (let i = 0; i < openBraces - closeBraces; i++) {
      fixedJson += '}';
    }
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      fixedJson += ']';
    }
    
    // 修复3: 处理尾部逗号
    fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1');
    
    // 修复4: 处理缺失的引号
    fixedJson = fixedJson.replace(/(\w+):/g, '"$1":');
    
    addLogEntry(`尝试修复后的JSON: ${fixedJson.substring(0, 100)}...`, 'info');
    
    try {
      return JSON.parse(fixedJson);
    } catch (secondError) {
      addLogEntry(`JSON修复后仍然解析失败: ${secondError.message}`, 'error');
      
      // 作为最后的手段，尝试提取键值对并构建基本结构
      try {
        const fallbackResult = {};
        const keyValueMatches = fixedJson.match(/"([^"]+)":\s*\[([^\]]*)\]/g);
        
        if (keyValueMatches && keyValueMatches.length > 0) {
          addLogEntry(`尝试从键值对构建JSON结构...`, 'warning');
          
          keyValueMatches.forEach(match => {
            const kvMatch = match.match(/"([^"]+)":\s*\[([^\]]*)\]/);
            if (kvMatch) {
              const category = kvMatch[1];
              const content = kvMatch[2];
              
              // 尝试解析书签对象
              const bookmarks = [];
              const bookmarkMatches = content.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/g);
              
              if (bookmarkMatches) {
                bookmarkMatches.forEach(bmMatch => {
                  const bmParts = bmMatch.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/);
                  if (bmParts) {
                    bookmarks.push({
                      title: bmParts[1],
                      url: bmParts[2]
                    });
                  }
                });
              }
              
              if (bookmarks.length > 0) {
                fallbackResult[category] = bookmarks;
              }
            }
          });
          
          if (Object.keys(fallbackResult).length > 0) {
            addLogEntry(`成功从键值对构建了${Object.keys(fallbackResult).length}个分类`, 'success');
            return fallbackResult;
          }
        }
      } catch (fallbackError) {
        addLogEntry(`备用解析方案也失败了: ${fallbackError.message}`, 'error');
      }
      
      // 如果所有尝试都失败了，抛出原始错误
      throw new Error(`JSON解析失败，已尝试多种修复方案: ${firstError.message}`);
    }
  }
}

// 通用JSON提取函数
function extractJsonFromText(responseText) {
  addLogEntry(`正在从响应中提取JSON数据...`, 'info');
  
  // 多种JSON提取策略
  let jsonText = '';
  
  // 策略1: 寻找完整的JSON代码块
  const codeBlockMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                         responseText.match(/```\s*([\s\S]*?)\s*```/);
  
  if (codeBlockMatch) {
    jsonText = codeBlockMatch[1].trim();
    addLogEntry(`从代码块中提取JSON，长度: ${jsonText.length}字符`, 'success');
  } else {
    // 策略2: 寻找第一个完整的JSON对象
    const jsonObjectMatch = responseText.match(/{[\s\S]*}/);
    if (jsonObjectMatch) {
      jsonText = jsonObjectMatch[0];
      addLogEntry(`从文本中提取JSON对象，长度: ${jsonText.length}字符`, 'success');
    } else {
      // 策略3: 使用整个响应
      jsonText = responseText.trim();
      addLogEntry(`未找到JSON格式标记，使用整个响应作为JSON`, 'warning');
    }
  }
  
  return jsonText;
}

// 调用Gemini API
async function callGeminiApi(prompt, apiKey, model) {
  try {
    // 构建URL，注意版本号
    const apiVersion = model.startsWith('gemini-1.5') ? 'v1' : 'v1beta';
    const url = `https://generativelanguage.googleapis.com/${apiVersion}/models/${model}:generateContent?key=${apiKey}`;
    
    console.log(`正在调用Gemini API，模型: ${model}`);
    addLogEntry(`正在调用Gemini API，模型: ${model}`, 'info');
    
    // 记录发送的数据，用于调试
    const requestData = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048
      }
    };
    
    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);
    
    addLogEntry(`发送请求到: ${apiVersion} 版本API...`, 'info');
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('Gemini API错误响应:', errorData);
      addLogEntry(`Gemini API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    addLogEntry(`Gemini API请求成功，正在处理响应...`, 'info');
    const data = await response.json();
    
    // 检查响应格式
    if (!data.candidates || data.candidates.length === 0) {
      console.error('Gemini API返回无效数据:', data);
      addLogEntry(`Gemini API返回无效数据，没有candidates`, 'error');
      throw new Error('API返回数据无效，没有candidates');
    }
    
    // 提取响应文本
    const responseText = data.candidates[0].content.parts[0].text;
    addLogEntry(`成功获取API响应，内容长度: ${responseText.length}字符`, 'success');
    
    // 保存完整响应以便调试
    console.log('API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('Gemini API调用出错:', error);
    addLogEntry(`Gemini API调用失败: ${error.message}`, 'error');
    throw new Error(`Gemini API调用失败: ${error.message}`);
  }
}

// 调用OpenAI API
async function callOpenAiApi(prompt, apiKey, model) {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'system',
            content: '你是一个书签分类助手，请将用户提供的书签分类，并以JSON格式返回。'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3
      })
    });
    
    if (!response.ok) {
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // 提取响应文本
    const responseText = data.choices[0].message.content;
    addLogEntry(`成功获取OpenAI API响应，内容长度: ${responseText.length}字符`, 'success');
    console.log('OpenAI API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      addLogEntry(`OpenAI JSON解析成功，包含${categoryNames.length}个分类`, 'success');
      
      return result;
    } catch (jsonError) {
      console.error('OpenAI JSON解析失败:', jsonError);
      addLogEntry(`OpenAI JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('OpenAI API调用出错:', error);
    throw new Error(`OpenAI API调用失败: ${error.message}`);
  }
}

// 调用自定义API分析书签
async function callCustomApi(apiKey, customApiUrl, model, prompt) {
  try {
    console.log('调用自定义API，URL:', customApiUrl);
    addLogEntry(`正在调用自定义API，模型: ${model}`, 'info');
    
    // 准备请求内容 - 提供多种可能的消息格式，增加兼容性
    const requestData = {
      model: model,
      prompt: prompt,
      message: prompt,
      // 兼容更多API格式
      messages: [
        { role: "user", content: prompt }
      ],
      content: prompt,
      input: prompt
    };

    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);

    addLogEntry(`发送请求到自定义API...`, 'info');
    const response = await fetch(customApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify(requestData)
    });

    const responseData = await response.json();
    if (!response.ok) {
      console.error('自定义API错误响应:', responseData);
      addLogEntry(`自定义API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API响应错误: ${response.status} - ${JSON.stringify(responseData)}`);
    }

    addLogEntry(`自定义API请求成功，正在处理响应...`, 'info');
    console.log('API完整响应:', responseData);

    // 处理不同格式的API响应，提取文本内容
    let resultText = '';
    
    // 1. 直接返回字符串
    if (typeof responseData === 'string') {
      resultText = responseData;
    }
    // 2. 有标准字段的情况
    else if (responseData.text || responseData.content || responseData.message || responseData.response) {
      resultText = responseData.text || responseData.content || responseData.message || responseData.response;
    }
    // 3. OpenAI格式
    else if (responseData.choices && responseData.choices.length > 0) {
      resultText = responseData.choices[0].text || responseData.choices[0].message?.content;
    }
    // 4. 有result字段的情况
    else if (responseData.result) {
      if (typeof responseData.result === 'string') {
        resultText = responseData.result;
      } else {
        // 如果result是对象，可能直接就是分类结果
        console.log('检测到result字段为对象，直接返回:', responseData.result);
        addLogEntry(`检测到result字段为对象，直接返回`, 'info');
        return responseData.result;
      }
    }
    // 5. 整个响应就是结果
    else {
      console.log('未找到标准结果字段，尝试使用整个响应');
      addLogEntry(`未找到标准结果字段，尝试使用整个响应`, 'warning');
      resultText = JSON.stringify(responseData);
    }

    if (!resultText) {
      throw new Error('无法从API响应中提取文本内容');
    }

    addLogEntry(`成功获取API响应，内容长度: ${resultText.length}字符`, 'success');
    console.log('提取的响应文本:', resultText);

    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(resultText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用共享的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('自定义API调用出错:', error);
    addLogEntry(`自定义API调用失败: ${error.message}`, 'error');
    throw new Error(`自定义API调用失败: ${error.message}`);
  }
}

// 显示分类结果
function displayCategories(categories, maxCategories = Infinity) {
  const resultsContainer = document.getElementById('results');
  resultsContainer.innerHTML = '';
  
  // 记录详细分类结果到日志
  addLogEntry(`开始显示分类结果...`, 'info');
  addLogEntry(`总共有 ${Object.keys(categories).length} 个分类`, 'info');
  
  // 优化：如果类别太多，按大小排序并限制显示数量
  const allCategories = Object.entries(categories)
    .sort((a, b) => b[1].length - a[1].length);
  
  const totalCategories = allCategories.length;
  
  // 输出详细分类信息到日志
  addLogEntry(`分类详情:`, 'info');
  allCategories.forEach(([category, items], index) => {
    addLogEntry(`  ${index+1}. ${category}: ${items.length}个书签`, 'info');
    
    // 只在日志中显示前3个书签示例
    if (items.length > 0) {
      const examples = items.slice(0, 3);
      examples.forEach((item, i) => {
        addLogEntry(`    ${i+1}) "${item.title}" (${item.url ? item.url.substring(0, 30) + '...' : '无URL'})`, 'info');
      });
      
      if (items.length > 3) {
        addLogEntry(`    ... 以及${items.length - 3}个其他书签`, 'info');
      }
    }
  });
  
  // 如果类别超过限制，显示分页控制
  if (totalCategories > maxCategories && maxCategories !== Infinity) {
    const paginationInfo = document.createElement('div');
    paginationInfo.className = 'pagination-info';
    paginationInfo.textContent = `显示${Math.min(maxCategories, totalCategories)}个类别中的前${maxCategories}个（按书签数量排序）`;
    
    const showAllButton = document.createElement('button');
    showAllButton.className = 'btn-small';
    showAllButton.textContent = '显示全部';
    showAllButton.onclick = () => displayCategories(categories);
    
    paginationInfo.appendChild(document.createTextNode(' '));
    paginationInfo.appendChild(showAllButton);
    resultsContainer.appendChild(paginationInfo);
    
    addLogEntry(`由于类别过多，UI中仅显示前${maxCategories}个类别`, 'info');
  }

  // 在分析完成后添加优化按钮
  if (maxCategories === Infinity) {
    const optimizeInfo = document.createElement('div');
    optimizeInfo.className = 'pagination-info';
    
    const optimizeForBrowserButton = document.createElement('button');
    optimizeForBrowserButton.className = 'btn-small';
    optimizeForBrowserButton.textContent = '优化为浏览器标签页结构';
    optimizeForBrowserButton.onclick = () => optimizeForBrowserTabs(categories);
    
    optimizeInfo.appendChild(optimizeForBrowserButton);
    resultsContainer.appendChild(optimizeInfo);
  }
  
  // 仅显示限制数量的类别
  const displayedCategories = allCategories.slice(0, maxCategories);
  
  // 性能优化：使用文档片段而不是直接操作DOM
  const fragment = document.createDocumentFragment();
  
  for (const [category, items] of displayedCategories) {
    const categoryElement = document.createElement('div');
    categoryElement.className = 'category';
    
    const categoryName = document.createElement('div');
    categoryName.className = 'category-name';
    categoryName.textContent = `${category} (${items.length})`;
    categoryElement.appendChild(categoryName);
    
    // 只显示前8个书签，如果超过8个，显示"更多..."
    const displayCount = Math.min(items.length, 8);
    
    // 使用内部文档片段进一步优化
    const itemsFragment = document.createDocumentFragment();
    
    for (let i = 0; i < displayCount; i++) {
      const item = items[i];
      const bookmarkItem = document.createElement('div');
      bookmarkItem.className = 'bookmark-item';
      
      const link = document.createElement('a');
      link.href = item.url;
      link.textContent = item.title || item.url;
      link.title = item.url;
      link.target = '_blank';
      
      bookmarkItem.appendChild(link);
      itemsFragment.appendChild(bookmarkItem);
    }
    
    // 如果有更多书签，显示"更多..."并添加展开功能
    if (items.length > 8) {
      const moreItem = document.createElement('div');
      moreItem.className = 'bookmark-item more-item';
      moreItem.textContent = `...还有 ${items.length - 8} 个书签`;
      
      // 添加点击展开功能
      moreItem.onclick = function() {
        // 已经展开的情况下折叠
        if (this.expanded) {
          // 移除额外书签
          const extras = categoryElement.querySelectorAll('.extra-bookmark');
          extras.forEach(item => item.remove());
          
          // 恢复文本和状态
          this.textContent = `...还有 ${items.length - 8} 个书签`;
          this.expanded = false;
          return;
        }
        
        // 未展开的情况下展开显示所有书签
        const extraItemsFragment = document.createDocumentFragment();
        
        for (let i = 8; i < items.length; i++) {
          const item = items[i];
          const bookmarkItem = document.createElement('div');
          bookmarkItem.className = 'bookmark-item extra-bookmark';
          
          const link = document.createElement('a');
          link.href = item.url;
          link.textContent = item.title || item.url;
          link.title = item.url;
          link.target = '_blank';
          
          bookmarkItem.appendChild(link);
          extraItemsFragment.appendChild(bookmarkItem);
        }
        
        // 插入额外书签
        categoryElement.insertBefore(extraItemsFragment, this);
        
        // 更新"更多"项文本和状态
        this.textContent = "折叠";
        this.expanded = true;
      };
      
      itemsFragment.appendChild(moreItem);
    }
    
    categoryElement.appendChild(itemsFragment);
    fragment.appendChild(categoryElement);
  }
  
  resultsContainer.appendChild(fragment);
  
  // 如果还有更多类别未显示，添加"查看更多类别"按钮
  if (allCategories.length > maxCategories && maxCategories !== Infinity) {
    const viewMoreButton = document.createElement('button');
    viewMoreButton.className = 'btn';
    viewMoreButton.textContent = `查看剩余 ${allCategories.length - maxCategories} 个类别`;
    viewMoreButton.onclick = () => displayCategories(categories);
    
    resultsContainer.appendChild(viewMoreButton);
  }
  
  addLogEntry(`分类结果显示完成`, 'success');
}

// 优化为浏览器标签页结构
async function optimizeForBrowserTabs(categories) {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    return;
  }
  
  // 确认操作
  if (!confirm('此操作将重新组织分类，创建更符合浏览器标签页结构的分组。是否继续？')) {
    return;
  }
  
  addLogEntry('正在优化分类结构为浏览器标签页...', 'info');
  showLoading(true);
  
  try {
    // 默认标签页数量，通常浏览器有7-8个标签页
    const TARGET_TAB_COUNT = 7;
    
    // 根据内容相似性将现有分类整合成约7个大分类
    const primaryCategories = [
      {name: "工作与生产力", patterns: ["工作", "办公", "文档", "生产力", "效率", "管理", "会议", "邮箱", "协作"]},
      {name: "技术与开发", patterns: ["技术", "编程", "开发", "代码", "程序", "设计", "博客", "github", "stack"]},
      {name: "学习与教育", patterns: ["学习", "教育", "课程", "培训", "知识", "教程", "学校", "研究", "科学"]},
      {name: "娱乐与休闲", patterns: ["娱乐", "视频", "音乐", "游戏", "电影", "电视", "动漫", "直播", "体育"]},
      {name: "社交与媒体", patterns: ["社交", "媒体", "新闻", "资讯", "论坛", "社区", "微博", "朋友", "交友"]},
      {name: "购物与消费", patterns: ["购物", "电商", "消费", "商城", "网购", "优惠", "团购", "店铺", "商品"]},
      {name: "生活与服务", patterns: ["生活", "服务", "餐饮", "美食", "旅游", "出行", "健康", "医疗", "银行"]}
    ];
    
    // 创建新的分类结构
    const optimizedCategories = {};
    primaryCategories.forEach(pc => {
      optimizedCategories[pc.name] = [];
    });
    optimizedCategories["其他"] = []; // 默认兜底分类
    
    // 将所有书签分配到新的分类中
    for (const [category, bookmarks] of Object.entries(categories)) {
      // 为当前分类找到最匹配的主分类
      let bestMatch = null;
      let highestScore = 0;
      
      // 计算当前分类与每个主分类的匹配度
      for (const pc of primaryCategories) {
        let score = 0;
        // 分类名称匹配
        for (const pattern of pc.patterns) {
          if (category.toLowerCase().includes(pattern)) {
            score += 3;  // 分类名匹配权重高
            break;
          }
        }
        
        // 书签内容匹配
        for (const bookmark of bookmarks) {
          const title = bookmark.title?.toLowerCase() || '';
          const url = bookmark.url?.toLowerCase() || '';
          
          for (const pattern of pc.patterns) {
            if (title.includes(pattern) || url.includes(pattern)) {
              score += 1;  // 每个书签匹配加1分
            }
          }
        }
        
        // 更新最佳匹配
        if (score > highestScore) {
          highestScore = score;
          bestMatch = pc.name;
        }
      }
      
      // 分配书签
      if (bestMatch && highestScore > 0) {
        optimizedCategories[bestMatch] = optimizedCategories[bestMatch].concat(bookmarks);
      } else {
        optimizedCategories["其他"] = optimizedCategories["其他"].concat(bookmarks);
      }
    }
    
    // 移除空分类
    Object.keys(optimizedCategories).forEach(key => {
      if (optimizedCategories[key].length === 0) {
        delete optimizedCategories[key];
      }
    });
    
    // 保存优化后的分类
    categories = optimizedCategories;
    
    // 更新历史版本
    await saveBookmarkHistory('浏览器标签页优化');
    
    // 显示优化后的分类
    displayCategories(categories);
    
    // 更新状态
    showStatus(`已优化为${Object.keys(categories).length}个主要分类，更符合浏览器标签页结构`, 'success');
    addLogEntry(`优化完成，已将书签重组为${Object.keys(categories).length}个主要分类`, 'success');
  } catch (error) {
    console.error('优化分类结构失败:', error);
    showStatus(`优化失败: ${error.message}`, 'error');
    addLogEntry(`优化分类结构失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 整理书签
async function organizeBookmarks() {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    addLogEntry('无法整理书签：请先进行分析', 'error');
    return;
  }
  
  addLogEntry('开始整理书签到文件夹...', 'info');
  showLoading(true);
  showProgress(true);
  showStatus('正在整理书签...');
  
  try {
    // 获取"其他书签"文件夹ID
    const otherBookmarksId = '2';
    addLogEntry(`目标文件夹："其他书签" (ID: ${otherBookmarksId})`, 'info');
    
    let organizedCount = 0;
    const totalCount = Object.values(categories).reduce((sum, items) => sum + items.length, 0);
    addLogEntry(`总共需要整理 ${totalCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'info');
    
    // 对每个分类创建文件夹
    for (const category of Object.keys(categories)) {
      // 创建分类文件夹
      addLogEntry(`正在创建/检查分类文件夹: "${category}"`, 'info');
      const categoryFolder = await createBookmarkFolder(category, otherBookmarksId);
      addLogEntry(`分类文件夹 "${category}" 已就绪 (ID: ${categoryFolder.id})`, 'success');
      
      // 移动书签到对应文件夹
      const itemsInCategory = categories[category].length;
      addLogEntry(`开始移动 ${itemsInCategory} 个书签到 "${category}" 文件夹`, 'info');
      
      for (const bookmark of categories[category]) {
        // 查找书签原始ID
        const originalBookmark = bookmarks.find(b => b.url === bookmark.url && b.title === bookmark.title);
        
        if (originalBookmark) {
          await moveBookmark(originalBookmark.id, categoryFolder.id);
          organizedCount++;
          
          // 更新进度条
          updateProgress(organizedCount, totalCount);
          
          // 每整理10个书签更新一次状态
          if (organizedCount % 10 === 0) {
            showStatus(`正在整理书签...${organizedCount}/${totalCount}`);
            addLogEntry(`已整理 ${organizedCount}/${totalCount} 个书签`, 'info');
          }
        } else {
          addLogEntry(`警告：无法找到书签 "${bookmark.title}" 的原始ID`, 'warning');
        }
      }
      
      addLogEntry(`完成 "${category}" 类别的整理`, 'success');
    }
    
    showStatus(`书签整理完成！共整理 ${organizedCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'success');
    addLogEntry(`===============================`, 'success');
    addLogEntry(`整理完成！共整理 ${organizedCount}/${totalCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'success');
    addLogEntry(`===============================`, 'success');
    
    // 保存历史版本
    await saveBookmarkHistory('整理后');
    
  } catch (error) {
    console.error('整理书签时出错:', error);
    showStatus(`整理出错: ${error.message}`, 'error');
    addLogEntry(`整理出错: ${error.message}`, 'error');
  } finally {
    showLoading(false);
    showProgress(false);
  }
}

// 创建书签文件夹
function createBookmarkFolder(title, parentId) {
  return new Promise((resolve, reject) => {
    // 先检查是否已存在同名文件夹
    chrome.bookmarks.getChildren(parentId, (children) => {
      const existingFolder = children.find(child => 
        child.title === title && !child.url
      );
      
      if (existingFolder) {
        resolve(existingFolder);
      } else {
        // 创建新文件夹
        chrome.bookmarks.create({
          parentId: parentId,
          title: title
        }, (newFolder) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(newFolder);
          }
        });
      }
    });
  });
}

// 移动书签
function moveBookmark(bookmarkId, newParentId) {
  return new Promise((resolve, reject) => {
    chrome.bookmarks.move(bookmarkId, { parentId: newParentId }, (result) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else {
        resolve(result);
      }
    });
  });
}

// 导出分类结果为CSV文件
function exportBookmarks() {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    addLogEntry('无法导出：请先进行分析', 'error');
    return;
  }
  
  addLogEntry('开始导出分类结果为CSV文件...', 'info');
  
  try {
    // 创建CSV内容
    let csvContent = '类别,标题,URL\n';
    let totalRows = 0;
    
    for (const [category, items] of Object.entries(categories)) {
      addLogEntry(`正在处理"${category}"类别 (${items.length}个书签)...`, 'info');
      
      for (const item of items) {
        // 处理CSV特殊字符
        const safeTitle = item.title ? `"${item.title.replace(/"/g, '""')}"` : '';
        const safeUrl = `"${item.url.replace(/"/g, '""')}"`;
        
        csvContent += `"${category}",${safeTitle},${safeUrl}\n`;
        totalRows++;
      }
    }
    
    addLogEntry(`CSV内容准备完成，总共 ${totalRows} 行数据`, 'success');
    
    // 创建下载链接
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 设置下载属性
    const fileName = `书签分类_${new Date().toISOString().slice(0, 10)}.csv`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    // 添加到DOM, 触发下载, 然后移除
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`CSV文件"${fileName}"下载已开始`, 'success');
    showStatus('CSV文件导出成功', 'success');
  } catch (error) {
    console.error('导出CSV时出错:', error);
    addLogEntry(`导出CSV失败: ${error.message}`, 'error');
    showStatus('导出失败', 'error');
  }
}

// 显示状态信息
function showStatus(message, type = '') {
  const statusElement = document.getElementById('status');
  statusElement.textContent = message;
  statusElement.style.display = 'block';
  
  // 清除所有类
  statusElement.className = 'status';
  
  // 添加类型类
  if (type) {
    statusElement.classList.add(type);
  }
}

// 显示/隐藏加载指示器
function showLoading(show) {
  document.getElementById('loading').style.display = show ? 'block' : 'none';
}

// 显示/隐藏进度条
function showProgress(show) {
  const progressElement = document.getElementById('progress');
  
  if (show) {
    progressElement.style.display = 'block';
    // 重置进度条
    document.getElementById('progress-bar').style.width = '0%';
  } else {
    progressElement.style.display = 'none';
  }
}

// 保存书签分类历史版本
async function saveBookmarkHistory(suffix = '') {
  try {
    const timestamp = Date.now();
    const historyId = `history_${timestamp}`;
    
    // 创建版本描述
    const categoryCount = Object.keys(categories).length;
    const description = `${totalBookmarksCount}个书签分为${categoryCount}个类别${suffix ? ` (${suffix})` : ''}`;
    
    // 构建历史记录对象
    const historyEntry = {
      id: historyId,
      timestamp,
      description,
      categories: JSON.parse(JSON.stringify(categories)),
      bookmarkCount: totalBookmarksCount,
      dateString: new Date(timestamp).toLocaleString()
    };
    
    // 获取现有历史记录
    const result = await chrome.storage.local.get('bookmarkHistory');
    const history = result.bookmarkHistory || [];
    
    // 添加新版本并保存
    history.unshift(historyEntry);
    
    // 限制历史记录数量（保留最近10条）
    const limitedHistory = history.slice(0, 10);
    
    await chrome.storage.local.set({ bookmarkHistory: limitedHistory });
    addLogEntry(`历史版本已保存: ${description}`, 'success');
  } catch (error) {
    console.error('保存历史版本失败:', error);
    addLogEntry(`保存历史版本失败: ${error.message}`, 'error');
  }
}

// 打开历史版本页面
function openHistoryPage() {
  chrome.tabs.create({ url: 'history.html' });
}

// 生成可视化图表
function generateVisualizations() {
  setTimeout(() => {
    try {
      // 显示可视化容器
      document.querySelector('.visualization-container').classList.remove('hidden');
      
      let successCount = 0;
      let totalAttempts = 3;
      
      // 检查Chart.js是否可用
      if (typeof Chart === 'undefined') {
        addLogEntry('Chart.js库未加载，跳过饼图生成', 'warning');
      } else {
        try {
          // 生成饼图
          generateCategoryPieChart();
          successCount++;
          addLogEntry('饼图生成成功', 'success');
        } catch (chartError) {
          addLogEntry(`饼图生成失败: ${chartError.message}`, 'error');
        }
      }
      
      // 检查D3是否可用
      if (typeof d3 === 'undefined') {
        addLogEntry('D3.js库未加载，跳过树形图生成', 'warning');
      } else {
        try {
          // 生成树形图
          generateCategoryTreeView();
          successCount++;
          addLogEntry('树形图生成成功', 'success');
        } catch (d3Error) {
          addLogEntry(`树形图生成失败: ${d3Error.message}`, 'error');
        }
      }
      
      // 生成标签云（不依赖外部库）
      try {
        generateTagCloud();
        successCount++;
        addLogEntry('标签云生成成功', 'success');
      } catch (tagCloudError) {
        addLogEntry(`标签云生成失败: ${tagCloudError.message}`, 'error');
      }
      
      if (successCount > 0) {
        addLogEntry(`可视化图表生成完成，成功生成 ${successCount}/${totalAttempts} 个图表`, 'success');
      } else {
        addLogEntry('所有可视化图表生成均失败', 'error');
        // 显示一个简单的文本统计作为备用
        showSimpleStatistics();
      }
      
    } catch (error) {
      console.error('生成可视化图表失败:', error);
      addLogEntry(`生成可视化图表失败: ${error.message}`, 'error');
      
      // 显示简单统计作为备用
      showSimpleStatistics();
    }
  }, 500);
}

// 显示简单的文本统计（备用方案）
function showSimpleStatistics() {
  try {
    const container = document.querySelector('.visualization-content');
    if (!container) return;
    
    // 创建简单统计面板
    const statsDiv = document.createElement('div');
    statsDiv.innerHTML = `
      <h3>书签分类统计</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
        ${Object.entries(categories)
          .sort((a, b) => b[1].length - a[1].length)
          .slice(0, 10)
          .map(([category, items]) => `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #4285f4;">
              <div style="font-weight: bold; color: #1a73e8; margin-bottom: 5px;">${category}</div>
              <div style="font-size: 24px; font-weight: bold; color: #34a853;">${items.length}</div>
              <div style="font-size: 12px; color: #5f6368;">个书签</div>
            </div>
          `).join('')}
      </div>
    `;
    
    // 替换可视化内容
    container.innerHTML = '';
    container.appendChild(statsDiv);
    
    addLogEntry('显示简单文本统计作为备用方案', 'info');
  } catch (error) {
    addLogEntry(`备用统计显示失败: ${error.message}`, 'error');
  }
}

// 切换可视化选项卡
function switchVisualizationTab(event) {
  // 移除所有标签页和内容的active类
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelectorAll('.viz-panel').forEach(panel => {
    panel.classList.remove('active');
  });
  
  // 设置当前标签页为active
  event.target.classList.add('active');
  
  // 显示对应的内容面板
  const tabName = event.target.dataset.tab;
  document.getElementById(`${tabName}-container`).classList.add('active');
}

// ======== 书签检测功能 ========

// 检测重复书签
async function detectDuplicateBookmarks() {
  addLogEntry('开始检测重复书签...', 'info');
  showLoading(true);
  showStatus('正在检测重复书签...');
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    addLogEntry(`获取到 ${allBookmarks.length} 个书签，开始分析重复项`, 'info');
    
    // 按URL分组检测重复
    const urlGroups = {};
    const titleGroups = {};
    
    allBookmarks.forEach(bookmark => {
      // 按URL分组
      const normalizedUrl = normalizeUrl(bookmark.url);
      if (!urlGroups[normalizedUrl]) {
        urlGroups[normalizedUrl] = [];
      }
      urlGroups[normalizedUrl].push(bookmark);
      
      // 按标题分组（用于检测可能的重复）
      const normalizedTitle = bookmark.title.toLowerCase().trim();
      if (normalizedTitle && normalizedTitle.length > 3) {
        if (!titleGroups[normalizedTitle]) {
          titleGroups[normalizedTitle] = [];
        }
        titleGroups[normalizedTitle].push(bookmark);
      }
    });
    
    // 找出重复项
    const duplicateGroups = [];
    
    // URL重复
    Object.entries(urlGroups).forEach(([url, bookmarks]) => {
      if (bookmarks.length > 1) {
        duplicateGroups.push({
          type: 'url',
          key: url,
          bookmarks: bookmarks,
          reason: 'URL相同'
        });
      }
    });
    
    // 标题重复（排除已经在URL重复中的）
    Object.entries(titleGroups).forEach(([title, bookmarks]) => {
      if (bookmarks.length > 1) {
        // 检查是否已经在URL重复组中
        const urls = bookmarks.map(b => normalizeUrl(b.url));
        const isAlreadyDetected = duplicateGroups.some(group => 
          group.type === 'url' && urls.some(url => url === group.key)
        );
        
        if (!isAlreadyDetected) {
          duplicateGroups.push({
            type: 'title',
            key: title,
            bookmarks: bookmarks,
            reason: '标题相同'
          });
        }
      }
    });
    
    addLogEntry(`检测完成，发现 ${duplicateGroups.length} 组重复书签`, 'success');
    
    // 显示检测结果
    displayDuplicateResults(duplicateGroups);
    showStatus(`检测完成，发现 ${duplicateGroups.length} 组重复书签`, 'success');
    
  } catch (error) {
    console.error('检测重复书签失败:', error);
    addLogEntry(`检测重复书签失败: ${error.message}`, 'error');
    showStatus(`检测失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 标准化URL（去除查询参数、锚点等）
function normalizeUrl(url) {
  try {
    const urlObj = new URL(url);
    // 移除www前缀
    let hostname = urlObj.hostname.replace(/^www\./, '');
    // 移除尾随斜杠
    let pathname = urlObj.pathname.replace(/\/$/, '') || '/';
    
    return `${urlObj.protocol}//${hostname}${pathname}`;
  } catch (e) {
    return url.toLowerCase().trim();
  }
}

// 显示重复书签检测结果
function displayDuplicateResults(duplicateGroups) {
  const container = document.getElementById('detection-container');
  const duplicateResults = document.getElementById('duplicate-results');
  const duplicateList = document.getElementById('duplicate-list');
  
  container.classList.remove('hidden');
  
  if (duplicateGroups.length === 0) {
    duplicateResults.classList.add('hidden');
    return;
  }
  
  duplicateResults.classList.remove('hidden');
  duplicateList.innerHTML = '';
  
  let totalDuplicates = 0;
  
  duplicateGroups.forEach((group, groupIndex) => {
    const groupElement = document.createElement('div');
    groupElement.className = 'duplicate-group';
    
    const groupHeader = document.createElement('div');
    groupHeader.className = 'duplicate-group-header';
    groupHeader.textContent = `${group.reason} - ${group.bookmarks.length} 个重复项`;
    groupElement.appendChild(groupHeader);
    
    group.bookmarks.forEach((bookmark, index) => {
      const item = document.createElement('div');
      item.className = 'detection-item';
      
      // 跳过第一个（保留原始），其余标记为重复
      const isDuplicate = index > 0;
      if (isDuplicate) {
        totalDuplicates++;
      }
      
      item.innerHTML = `
        <input type="checkbox" class="detection-checkbox" 
               data-type="duplicate" 
               data-id="${bookmark.id}" 
               ${isDuplicate ? 'checked' : 'disabled'}>
        <div class="detection-info">
          <div class="detection-title">${bookmark.title || '无标题'}</div>
          <div class="detection-url">${bookmark.url}</div>
          <div class="detection-meta">
            ${isDuplicate ? '📄 重复项' : '✅ 原始项'} | 
            ID: ${bookmark.id} | 
            父文件夹: ${bookmark.parentId}
          </div>
        </div>
      `;
      
      groupElement.appendChild(item);
    });
    
    duplicateList.appendChild(groupElement);
  });
  
  // 显示操作按钮
  document.getElementById('remove-duplicates').classList.remove('hidden');
  document.getElementById('select-all-duplicates').classList.remove('hidden');
  document.getElementById('deselect-all-duplicates').classList.remove('hidden');
  
  addLogEntry(`显示重复检测结果：${duplicateGroups.length} 组，共 ${totalDuplicates} 个重复项`, 'info');
}

// 检测失效书签
async function detectInvalidBookmarks() {
  addLogEntry('开始检测失效书签...', 'info');
  showLoading(true);
  showStatus('正在检测失效书签...');
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    addLogEntry(`获取到 ${allBookmarks.length} 个书签，开始检测失效链接`, 'info');
    
    const invalidBookmarks = [];
    const batchSize = 10; // 并发检测数量
    let checkedCount = 0;
    
    // 分批检测书签有效性
    for (let i = 0; i < allBookmarks.length; i += batchSize) {
      const batch = allBookmarks.slice(i, i + batchSize);
      
      // 并发检测当前批次
      const batchPromises = batch.map(async (bookmark) => {
        try {
          const isValid = await checkBookmarkValidity(bookmark.url);
          checkedCount++;
          
          // 更新进度
          if (checkedCount % 20 === 0) {
            showStatus(`正在检测失效书签... ${checkedCount}/${allBookmarks.length}`);
            addLogEntry(`已检测 ${checkedCount}/${allBookmarks.length} 个书签`, 'info');
          }
          
          if (!isValid) {
            invalidBookmarks.push(bookmark);
          }
        } catch (error) {
          addLogEntry(`检测书签 "${bookmark.title}" 时出错: ${error.message}`, 'warning');
          // 检测出错的也视为可能失效
          invalidBookmarks.push(bookmark);
        }
      });
      
      await Promise.all(batchPromises);
      
      // 批次间稍作延迟，避免过于频繁的请求
      if (i + batchSize < allBookmarks.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    addLogEntry(`检测完成，发现 ${invalidBookmarks.length} 个失效书签`, 'success');
    
    // 显示检测结果
    displayInvalidResults(invalidBookmarks);
    showStatus(`检测完成，发现 ${invalidBookmarks.length} 个失效书签`, 'success');
    
  } catch (error) {
    console.error('检测失效书签失败:', error);
    addLogEntry(`检测失效书签失败: ${error.message}`, 'error');
    showStatus(`检测失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 检查单个书签的有效性
async function checkBookmarkValidity(url) {
  return new Promise((resolve) => {
    // 设置超时时间
    const timeout = 10000; // 10秒超时
    
    const timeoutId = setTimeout(() => {
      resolve(false); // 超时视为失效
    }, timeout);
    
    // 使用fetch检测URL可访问性
    fetch(url, {
      method: 'HEAD', // 只获取头部信息，减少数据传输
      mode: 'no-cors', // 避免CORS问题
      cache: 'no-cache'
    })
    .then(response => {
      clearTimeout(timeoutId);
      // 对于no-cors模式，response.ok可能不准确，所以检查type
      resolve(response.type !== 'error');
    })
    .catch(error => {
      clearTimeout(timeoutId);
      // 网络错误或其他问题
      resolve(false);
    });
  });
}

// 显示失效书签检测结果
function displayInvalidResults(invalidBookmarks) {
  const container = document.getElementById('detection-container');
  const invalidResults = document.getElementById('invalid-results');
  const invalidList = document.getElementById('invalid-list');
  
  container.classList.remove('hidden');
  
  if (invalidBookmarks.length === 0) {
    invalidResults.classList.add('hidden');
    return;
  }
  
  invalidResults.classList.remove('hidden');
  invalidList.innerHTML = '';
  
  invalidBookmarks.forEach(bookmark => {
    const item = document.createElement('div');
    item.className = 'detection-item';
    
    item.innerHTML = `
      <input type="checkbox" class="detection-checkbox" 
             data-type="invalid" 
             data-id="${bookmark.id}" 
             checked>
      <div class="detection-info">
        <div class="detection-title">${bookmark.title || '无标题'}</div>
        <div class="detection-url">${bookmark.url}</div>
        <div class="detection-meta">
          ❌ 失效链接 | 
          ID: ${bookmark.id} | 
          父文件夹: ${bookmark.parentId}
        </div>
      </div>
    `;
    
    invalidList.appendChild(item);
  });
  
  // 显示操作按钮
  document.getElementById('remove-invalid').classList.remove('hidden');
  document.getElementById('select-all-invalid').classList.remove('hidden');
  document.getElementById('deselect-all-invalid').classList.remove('hidden');
  
  addLogEntry(`显示失效检测结果：${invalidBookmarks.length} 个失效书签`, 'info');
}

// 清理书签（检测空文件夹）
async function cleanupBookmarks() {
  addLogEntry('开始清理书签，检测空文件夹...', 'info');
  showLoading(true);
  showStatus('正在检测空文件夹...');
  
  try {
    // 获取书签树
    const bookmarkTree = await new Promise((resolve) => {
      chrome.bookmarks.getTree(resolve);
    });
    
    const emptyFolders = [];
    
    // 递归检查空文件夹
    function checkEmptyFolders(node) {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const hasBookmarks = node.children.some(child => child.url);
        const hasNonEmptySubfolders = node.children.some(child => 
          !child.url && child.children && child.children.length > 0
        );
        
        if (!hasBookmarks && !hasNonEmptySubfolders && node.children.length === 0) {
          // 空文件夹
          emptyFolders.push(node);
        }
        
        // 递归检查子文件夹
        node.children.forEach(checkEmptyFolders);
      }
    }
    
    bookmarkTree.forEach(checkEmptyFolders);
    
    addLogEntry(`检测完成，发现 ${emptyFolders.length} 个空文件夹`, 'success');
    
    // 显示检测结果
    displayEmptyFolderResults(emptyFolders);
    showStatus(`检测完成，发现 ${emptyFolders.length} 个空文件夹`, 'success');
    
  } catch (error) {
    console.error('清理书签失败:', error);
    addLogEntry(`清理书签失败: ${error.message}`, 'error');
    showStatus(`清理失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 显示空文件夹检测结果
function displayEmptyFolderResults(emptyFolders) {
  const container = document.getElementById('detection-container');
  const emptyFolderResults = document.getElementById('empty-folders-results');
  const emptyFolderList = document.getElementById('empty-folders-list');
  
  container.classList.remove('hidden');
  
  if (emptyFolders.length === 0) {
    emptyFolderResults.classList.add('hidden');
    return;
  }
  
  emptyFolderResults.classList.remove('hidden');
  emptyFolderList.innerHTML = '';
  
  emptyFolders.forEach(folder => {
    const item = document.createElement('div');
    item.className = 'detection-item';
    
    item.innerHTML = `
      <input type="checkbox" class="detection-checkbox" 
             data-type="empty-folder" 
             data-id="${folder.id}" 
             checked>
      <div class="detection-info">
        <div class="detection-title">📁 ${folder.title || '无标题文件夹'}</div>
        <div class="detection-url">空文件夹</div>
        <div class="detection-meta">
          🗂️ 空文件夹 | 
          ID: ${folder.id} | 
          父文件夹: ${folder.parentId}
        </div>
      </div>
    `;
    
    emptyFolderList.appendChild(item);
  });
  
  // 显示操作按钮
  document.getElementById('remove-empty-folders').classList.remove('hidden');
  document.getElementById('select-all-empty-folders').classList.remove('hidden');
  document.getElementById('deselect-all-empty-folders').classList.remove('hidden');
  
  addLogEntry(`显示空文件夹检测结果：${emptyFolders.length} 个空文件夹`, 'info');
}

// ======== 检测结果操作功能 ========

// 移除重复书签
async function removeDuplicateBookmarks() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="duplicate"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的重复书签', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个重复书签吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个重复书签...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const bookmarkId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.remove(bookmarkId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除书签 ${bookmarkId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个重复书签`, 'success');
    showStatus(`成功删除 ${deletedCount} 个重复书签`, 'success');
    
  } catch (error) {
    addLogEntry(`删除重复书签失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 移除失效书签
async function removeInvalidBookmarks() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="invalid"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的失效书签', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个失效书签吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个失效书签...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const bookmarkId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.remove(bookmarkId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除书签 ${bookmarkId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个失效书签`, 'success');
    showStatus(`成功删除 ${deletedCount} 个失效书签`, 'success');
    
  } catch (error) {
    addLogEntry(`删除失效书签失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 移除空文件夹
async function removeEmptyFolders() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="empty-folder"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的空文件夹', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个空文件夹吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个空文件夹...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const folderId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.removeTree(folderId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除文件夹 ${folderId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个空文件夹`, 'success');
    showStatus(`成功删除 ${deletedCount} 个空文件夹`, 'success');
    
  } catch (error) {
    addLogEntry(`删除空文件夹失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 选择/取消选择检测项目
function selectAllDetectionItems(type, select) {
  const checkboxes = document.querySelectorAll(`.detection-checkbox[data-type="${type}"]`);
  checkboxes.forEach(checkbox => {
    if (!checkbox.disabled) {
      checkbox.checked = select;
    }
  });
  
  addLogEntry(`${select ? '选择' : '取消选择'}了 ${checkboxes.length} 个${type}项目`, 'info');
}

// ======== 书签管理器功能 ========

// 打开书签管理器
async function openBookmarkManager() {
  addLogEntry('打开书签管理器...', 'info');
  showLoading(true);
  
  try {
    // 验证浏览器API可用性
    if (!chrome || !chrome.bookmarks) {
      throw new Error('Chrome书签API不可用，请检查扩展权限');
    }
    
    addLogEntry('Chrome书签API验证通过', 'success');
    
    // 加载书签树
    await loadBookmarkTree();
    
    // 验证数据完整性
    if (!bookmarkTreeData || bookmarkTreeData.length === 0) {
      throw new Error('未获取到书签数据或书签数据为空');
    }
    
    addLogEntry(`书签数据验证通过，包含 ${bookmarkTreeData.length} 个根节点`, 'success');
    
    // 显示书签管理器容器
    const container = document.getElementById('bookmark-manager-container');
    if (!container) {
      throw new Error('找不到书签管理器容器元素');
    }
    
    container.classList.remove('hidden');
    addLogEntry('书签管理器容器显示成功', 'success');
    
    // 渲染书签树
    renderBookmarkTree();
    
    // 验证渲染结果
    const treeContainer = document.getElementById('bookmark-tree');
    const renderedNodes = treeContainer.querySelectorAll('.tree-node');
    addLogEntry(`书签树渲染完成，共渲染 ${renderedNodes.length} 个节点`, 'success');
    
    // 验证统计面板
    const statsPanel = document.querySelector('.bookmark-stats-panel');
    if (statsPanel) {
      addLogEntry('统计面板创建成功', 'success');
    } else {
      addLogEntry('警告: 统计面板未正确创建', 'warning');
    }
    
    addLogEntry('书签管理器加载完成', 'success');
    showStatus('书签管理器已打开', 'success');
    
  } catch (error) {
    console.error('打开书签管理器失败:', error);
    addLogEntry(`打开书签管理器失败: ${error.message}`, 'error');
    showStatus(`打开失败: ${error.message}`, 'error');
    
    // 显示详细的错误诊断信息
    addLogEntry('开始错误诊断...', 'info');
    
    // 检查API权限
    if (!chrome) {
      addLogEntry('错误: Chrome扩展API不可用', 'error');
    } else if (!chrome.bookmarks) {
      addLogEntry('错误: Chrome书签API不可用，请检查manifest.json中的权限配置', 'error');
    } else {
      addLogEntry('Chrome API可用，错误可能来自其他原因', 'info');
    }
    
    // 检查DOM元素
    const container = document.getElementById('bookmark-manager-container');
    if (!container) {
      addLogEntry('错误: 找不到书签管理器容器元素 #bookmark-manager-container', 'error');
    }
    
    const treeContainer = document.getElementById('bookmark-tree');
    if (!treeContainer) {
      addLogEntry('错误: 找不到书签树容器元素 #bookmark-tree', 'error');
    }
    
  } finally {
    showLoading(false);
  }
}

// 加载书签树数据
async function loadBookmarkTree() {
  return new Promise((resolve, reject) => {
    chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
        return;
      }
      
      bookmarkTreeData = bookmarkTreeNodes;
      addLogEntry(`书签树加载完成，根节点数: ${bookmarkTreeNodes.length}`, 'info');
      
      // 添加详细的书签统计信息
      const stats = analyzeBookmarkTree(bookmarkTreeNodes);
      addLogEntry(`书签统计: 总计${stats.totalBookmarks}个书签, ${stats.totalFolders}个文件夹, ${stats.maxDepth}层深度`, 'success');
      addLogEntry(`文件夹分布: 书签栏${stats.bookmarkBar}个, 其他书签${stats.otherBookmarks}个, 移动设备书签${stats.mobileBookmarks}个`, 'info');
      
      resolve(bookmarkTreeNodes);
    });
  });
}

// 分析书签树统计信息
function analyzeBookmarkTree(nodes) {
  const stats = {
    totalBookmarks: 0,
    totalFolders: 0,
    maxDepth: 0,
    bookmarkBar: 0,
    otherBookmarks: 0,
    mobileBookmarks: 0
  };
  
  function analyzeNode(node, depth = 0) {
    stats.maxDepth = Math.max(stats.maxDepth, depth);
    
    if (node.url) {
      // 这是一个书签
      stats.totalBookmarks++;
      
      // 根据父节点ID统计分布
      if (node.parentId === '1') {
        stats.bookmarkBar++;
      } else if (node.parentId === '2') {
        stats.otherBookmarks++;
      } else if (node.parentId === '3') {
        stats.mobileBookmarks++;
      }
    } else if (node.children) {
      // 这是一个文件夹
      if (node.id !== '0') { // 排除根节点
        stats.totalFolders++;
      }
      
      // 递归分析子节点
      node.children.forEach(child => analyzeNode(child, depth + 1));
    }
  }
  
  nodes.forEach(node => analyzeNode(node));
  return stats;
}

// 渲染书签树
function renderBookmarkTree() {
  const container = document.getElementById('bookmark-tree');
  container.innerHTML = '';
  
  // 清空选择状态
  selectedBookmarks.clear();
  
  // 添加统计信息面板
  const statsPanel = document.createElement('div');
  statsPanel.className = 'bookmark-stats-panel';
  statsPanel.innerHTML = `
    <div class="stats-header">📊 书签统计</div>
    <div class="stats-content" id="bookmark-stats-content">正在计算...</div>
  `;
  container.appendChild(statsPanel);
  
  // 渲染每个根节点
  bookmarkTreeData.forEach(rootNode => {
    const treeElement = createTreeNode(rootNode, 0);
    container.appendChild(treeElement);
  });
  
  // 更新统计信息
  updateBookmarkStats();
  
  addLogEntry('书签树渲染完成', 'info');
  
  // 自动展开第一级文件夹（书签栏、其他书签等）
  setTimeout(() => {
    expandFirstLevelFolders();
  }, 100);
}

// 更新书签统计信息
function updateBookmarkStats() {
  const stats = analyzeBookmarkTree(bookmarkTreeData);
  const statsContent = document.getElementById('bookmark-stats-content');
  
  if (statsContent) {
    statsContent.innerHTML = `
      <div class="stat-item">📚 总书签: <strong>${stats.totalBookmarks}</strong></div>
      <div class="stat-item">📁 总文件夹: <strong>${stats.totalFolders}</strong></div>
      <div class="stat-item">📊 最大深度: <strong>${stats.maxDepth}</strong>层</div>
      <div class="stat-breakdown">
        <div>书签栏: ${stats.bookmarkBar} | 其他书签: ${stats.otherBookmarks} | 移动设备: ${stats.mobileBookmarks}</div>
      </div>
    `;
  }
}

// 展开第一级文件夹
function expandFirstLevelFolders() {
  // 找到所有第一级文件夹（书签栏、其他书签、移动设备书签等）
  const firstLevelFolders = document.querySelectorAll('.tree-node[style*="margin-left: 0px"] .tree-expand-btn, .tree-node[style*="margin-left: 20px"] .tree-expand-btn');
  
  let expandedCount = 0;
  firstLevelFolders.forEach(button => {
    const nodeElement = button.closest('.tree-node');
    const childrenContainer = nodeElement.querySelector('.tree-children');
    
    if (childrenContainer && childrenContainer.classList.contains('hidden')) {
      childrenContainer.classList.remove('hidden');
      button.textContent = '▼';
      expandedCount++;
    }
  });
  
  addLogEntry(`自动展开了${expandedCount}个主要文件夹`, 'info');
}

// 创建树节点
function createTreeNode(node, level) {
  const nodeElement = document.createElement('div');
  nodeElement.className = 'tree-node';
  nodeElement.style.marginLeft = `${level * 20}px`;
  nodeElement.dataset.nodeId = node.id;
  nodeElement.dataset.nodeType = node.url ? 'bookmark' : 'folder';
  
  // 添加拖拽功能
  nodeElement.draggable = true;
  nodeElement.addEventListener('dragstart', handleDragStart);
  nodeElement.addEventListener('dragover', handleDragOver);
  nodeElement.addEventListener('drop', handleDrop);
  nodeElement.addEventListener('dragend', handleDragEnd);
  
  // 添加调试信息
  if (level === 0) {
    addLogEntry(`创建根节点: ${node.title} (ID: ${node.id})`, 'info');
  }
  
  // 节点内容容器
  const nodeContent = document.createElement('div');
  nodeContent.className = 'tree-node-content';
  
  // 展开/折叠按钮（仅文件夹）
  if (!node.url && node.children) {
    const expandButton = document.createElement('button');
    expandButton.className = 'tree-expand-btn';
    expandButton.textContent = '▶';
    expandButton.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleNodeExpansion(nodeElement, expandButton);
    });
    nodeContent.appendChild(expandButton);
    
    // 添加文件夹书签数量显示
    const bookmarkCount = countBookmarksInFolder(node);
    if (bookmarkCount > 0) {
      const countSpan = document.createElement('span');
      countSpan.className = 'folder-count';
      countSpan.textContent = ` (${bookmarkCount})`;
      countSpan.title = `包含 ${bookmarkCount} 个书签`;
    }
  } else {
    // 书签项的占位符
    const spacer = document.createElement('span');
    spacer.className = 'tree-spacer';
    spacer.textContent = '  ';
    nodeContent.appendChild(spacer);
  }
  
  // 复选框
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'tree-checkbox';
  checkbox.addEventListener('change', (e) => {
    e.stopPropagation();
    toggleBookmarkSelection(node.id, checkbox.checked);
  });
  nodeContent.appendChild(checkbox);
  
  // 拖拽手柄
  const dragHandle = document.createElement('span');
  dragHandle.className = 'drag-handle';
  dragHandle.textContent = '⋮⋮';
  dragHandle.title = '拖拽以重新排序';
  nodeContent.appendChild(dragHandle);
  
  // 图标和标题
  const icon = document.createElement('span');
  icon.className = 'tree-icon';
  icon.textContent = node.url ? '🔖' : '📁';
  nodeContent.appendChild(icon);
  
  // 标题容器（支持内联编辑）
  const titleContainer = document.createElement('div');
  titleContainer.className = 'tree-title-container';
  
  const title = document.createElement('span');
  title.className = 'tree-title';
  title.textContent = node.title || '无标题';
  title.dataset.originalTitle = node.title || '';
  
  // 添加双击编辑功能
  title.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    startInlineEdit(title, node);
  });
  
  // 添加URL工具提示（仅书签）
  if (node.url) {
    title.title = node.url;
  }
  
  titleContainer.appendChild(title);
  
  // 内联编辑输入框（初始隐藏）
  const editInput = document.createElement('input');
  editInput.type = 'text';
  editInput.className = 'tree-title-edit hidden';
  editInput.value = node.title || '';
  editInput.addEventListener('blur', () => finishInlineEdit(editInput, title, node));
  editInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      finishInlineEdit(editInput, title, node);
    } else if (e.key === 'Escape') {
      cancelInlineEdit(editInput, title);
    }
  });
  
  titleContainer.appendChild(editInput);
  nodeContent.appendChild(titleContainer);
  
  // 操作按钮
  const actions = document.createElement('div');
  actions.className = 'tree-actions';
  
  // 内联编辑按钮
  const inlineEditBtn = document.createElement('button');
  inlineEditBtn.className = 'tree-action-btn inline-edit-btn';
  inlineEditBtn.textContent = '✏️';
  inlineEditBtn.title = '快速重命名';
  inlineEditBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    startInlineEdit(title, node);
  });
  actions.appendChild(inlineEditBtn);
  
  // 编辑按钮
  const editBtn = document.createElement('button');
  editBtn.className = 'tree-action-btn edit-btn';
  editBtn.textContent = '⚙️';
  editBtn.title = '详细编辑';
  editBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    try {
      addLogEntry(`编辑项目: ${node.title} (ID: ${node.id})`, 'info');
      editBookmarkItem(node);
    } catch (error) {
      addLogEntry(`编辑失败: ${error.message}`, 'error');
    }
  });
  actions.appendChild(editBtn);
  
  // 删除按钮
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'tree-action-btn delete-btn';
  deleteBtn.textContent = '🗑️';
  deleteBtn.title = '删除';
  deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    try {
      addLogEntry(`准备删除项目: ${node.title} (ID: ${node.id})`, 'info');
      deleteBookmarkItem(node);
    } catch (error) {
      addLogEntry(`删除失败: ${error.message}`, 'error');
    }
  });
  actions.appendChild(deleteBtn);
  
  nodeContent.appendChild(actions);
  nodeElement.appendChild(nodeContent);
  
  // 子节点容器（仅文件夹）
  if (!node.url && node.children) {
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'tree-children hidden'; // 默认隐藏，但会在renderBookmarkTree中自动展开主要文件夹
    
    let childBookmarkCount = 0;
    let childFolderCount = 0;
    
    node.children.forEach(child => {
      const childElement = createTreeNode(child, level + 1);
      childrenContainer.appendChild(childElement);
      
      if (child.url) {
        childBookmarkCount++;
      } else if (child.children) {
        childFolderCount++;
      }
    });
    
    nodeElement.appendChild(childrenContainer);
    
    // 记录文件夹内容统计
    if (level <= 2) { // 只记录前两级的详细信息
      addLogEntry(`文件夹"${node.title}"包含: ${childBookmarkCount}个书签, ${childFolderCount}个子文件夹`, 'info');
    }
  }
  
  return nodeElement;
}

// 计算文件夹中的书签数量
function countBookmarksInFolder(folderNode) {
  let count = 0;
  
  function countRecursive(node) {
    if (node.url) {
      count++;
    } else if (node.children) {
      node.children.forEach(countRecursive);
    }
  }
  
  if (folderNode.children) {
    folderNode.children.forEach(countRecursive);
  }
  
  return count;
}

// 切换节点展开/折叠
function toggleNodeExpansion(nodeElement, expandButton) {
  const childrenContainer = nodeElement.querySelector('.tree-children');
  if (!childrenContainer) return;
  
  const isExpanded = !childrenContainer.classList.contains('hidden');
  
  if (isExpanded) {
    childrenContainer.classList.add('hidden');
    expandButton.textContent = '▶';
  } else {
    childrenContainer.classList.remove('hidden');
    expandButton.textContent = '▼';
  }
}

// 展开/折叠所有文件夹
function expandAllFolders(expand) {
  const expandButtons = document.querySelectorAll('.tree-expand-btn');
  const childrenContainers = document.querySelectorAll('.tree-children');
  
  expandButtons.forEach(button => {
    button.textContent = expand ? '▼' : '▶';
  });
  
  childrenContainers.forEach(container => {
    if (expand) {
      container.classList.remove('hidden');
    } else {
      container.classList.add('hidden');
    }
  });
  
  addLogEntry(`${expand ? '展开' : '折叠'}了所有文件夹`, 'info');
}

// 切换书签选择状态
function toggleBookmarkSelection(nodeId, selected) {
  if (selected) {
    selectedBookmarks.add(nodeId);
  } else {
    selectedBookmarks.delete(nodeId);
  }
  
  // 更新批量操作按钮状态
  updateBatchActionButtons();
}

// 选择/取消选择所有书签
function selectAllBookmarks(select) {
  const checkboxes = document.querySelectorAll('.tree-checkbox');
  
  checkboxes.forEach(checkbox => {
    checkbox.checked = select;
    const nodeElement = checkbox.closest('.tree-node');
    const nodeId = nodeElement.dataset.nodeId;
    
    if (select) {
      selectedBookmarks.add(nodeId);
    } else {
      selectedBookmarks.delete(nodeId);
    }
  });
  
  updateBatchActionButtons();
  addLogEntry(`${select ? '选择' : '取消选择'}了所有书签`, 'info');
}

// 更新批量操作按钮状态
function updateBatchActionButtons() {
  const hasSelection = selectedBookmarks.size > 0;
  const batchButtons = document.querySelectorAll('.batch-action-btn');
  
  batchButtons.forEach(button => {
    button.disabled = !hasSelection;
  });
  
  // 更新选择计数显示
  const selectionCount = document.getElementById('selected-count');
  if (selectionCount) {
    selectionCount.textContent = `已选择 ${selectedBookmarks.size} 项`;
  }
  
  // 显示/隐藏批量操作工具栏
  const batchOperations = document.getElementById('batch-operations');
  if (batchOperations) {
    if (hasSelection) {
      batchOperations.classList.remove('hidden');
    } else {
      batchOperations.classList.add('hidden');
    }
  }
}

// 编辑书签项目
function editBookmarkItem(node) {
  currentEditingItem = node;
  
  // 填充编辑表单
  document.getElementById('edit-title').value = node.title || '';
  document.getElementById('edit-url').value = node.url || '';
  
  // 加载父文件夹选项
  loadParentFolderOptions(node.parentId);
  
  // 显示编辑模态框
  document.getElementById('edit-modal').classList.remove('hidden');
  
  addLogEntry(`开始编辑项目: ${node.title}`, 'info');
}

// 加载父文件夹选项
function loadParentFolderOptions(currentParentId) {
  const select = document.getElementById('edit-parent');
  select.innerHTML = '';
  
  // 递归添加文件夹选项
  function addFolderOptions(nodes, level = 0) {
    nodes.forEach(node => {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = '  '.repeat(level) + (node.title || '无标题文件夹');
        
        if (node.id === currentParentId) {
          option.selected = true;
        }
        
        select.appendChild(option);
        
        // 递归添加子文件夹
        addFolderOptions(node.children, level + 1);
      }
    });
  }
  
  addFolderOptions(bookmarkTreeData);
}

// 保存书签编辑
async function saveBookmarkEdit() {
  if (!currentEditingItem) return;
  
  const newTitle = document.getElementById('edit-title').value.trim();
  const newUrl = document.getElementById('edit-url').value.trim();
  const newParentId = document.getElementById('edit-parent').value;
  
  if (!newTitle) {
    showStatus('标题不能为空', 'error');
    return;
  }
  
  if (currentEditingItem.url && !newUrl) {
    showStatus('书签URL不能为空', 'error');
    return;
  }
  
  try {
    showLoading(true);
    
    // 更新书签
    const updateData = { title: newTitle };
    if (currentEditingItem.url) {
      updateData.url = newUrl;
    }
    
    await new Promise((resolve, reject) => {
      chrome.bookmarks.update(currentEditingItem.id, updateData, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
    // 如果父文件夹改变，移动书签
    if (newParentId !== currentEditingItem.parentId) {
      await new Promise((resolve, reject) => {
        chrome.bookmarks.move(currentEditingItem.id, { parentId: newParentId }, (result) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(result);
          }
        });
      });
    }
    
    addLogEntry(`成功更新项目: ${newTitle}`, 'success');
    showStatus('保存成功', 'success');
    
    // 关闭模态框并刷新树
    closeEditModal();
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error('保存编辑失败:', error);
    addLogEntry(`保存编辑失败: ${error.message}`, 'error');
    showStatus(`保存失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 关闭编辑模态框
function closeEditModal() {
  document.getElementById('edit-modal').classList.add('hidden');
  currentEditingItem = null;
}

// 删除书签项目
async function deleteBookmarkItem(node) {
  const itemType = node.url ? '书签' : '文件夹';
  
  if (!confirm(`确定要删除${itemType}"${node.title}"吗？此操作不可撤销。`)) {
    return;
  }
  
  try {
    showLoading(true);
    
    await new Promise((resolve, reject) => {
      if (node.url) {
        // 删除书签
        chrome.bookmarks.remove(node.id, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      } else {
        // 删除文件夹（包括所有子项）
        chrome.bookmarks.removeTree(node.id, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      }
    });
    
    addLogEntry(`成功删除${itemType}: ${node.title}`, 'success');
    showStatus(`删除${itemType}成功`, 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error(`删除${itemType}失败:`, error);
    addLogEntry(`删除${itemType}失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 刷新书签管理器
async function refreshBookmarkManager() {
  try {
    await loadBookmarkTree();
    renderBookmarkTree();
    addLogEntry('书签管理器已刷新', 'info');
  } catch (error) {
    addLogEntry(`刷新书签管理器失败: ${error.message}`, 'error');
  }
}

// 创建新文件夹
async function createNewFolder() {
  const folderName = prompt('请输入文件夹名称:');
  if (!folderName || !folderName.trim()) {
    return;
  }
  
  try {
    showLoading(true);
    
    // 默认在"其他书签"文件夹中创建
    const parentId = '2'; // 其他书签文件夹ID
    
    await new Promise((resolve, reject) => {
      chrome.bookmarks.create({
        parentId: parentId,
        title: folderName.trim()
      }, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
    addLogEntry(`成功创建文件夹: ${folderName}`, 'success');
    showStatus('文件夹创建成功', 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error('创建文件夹失败:', error);
    addLogEntry(`创建文件夹失败: ${error.message}`, 'error');
    showStatus(`创建失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// ======== 批量操作功能 ========

// 批量删除项目
async function batchDeleteItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要删除的项目', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除选中的 ${selectedBookmarks.size} 个项目吗？此操作不可撤销。`)) {
    return;
  }
  
  try {
    showLoading(true);
    addLogEntry(`开始批量删除 ${selectedBookmarks.size} 个项目...`, 'info');
    
    let deletedCount = 0;
    const selectedArray = Array.from(selectedBookmarks);
    
    for (const nodeId of selectedArray) {
      try {
        // 查找节点信息
        const node = findNodeById(nodeId);
        
        await new Promise((resolve, reject) => {
          if (node && node.url) {
            // 删除书签
            chrome.bookmarks.remove(nodeId, () => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve();
              }
            });
          } else {
            // 删除文件夹
            chrome.bookmarks.removeTree(nodeId, () => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve();
              }
            });
          }
        });
        
        deletedCount++;
        selectedBookmarks.delete(nodeId);
        
      } catch (error) {
        addLogEntry(`删除项目 ${nodeId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`批量删除完成，成功删除 ${deletedCount} 个项目`, 'success');
    showStatus(`批量删除完成，成功删除 ${deletedCount} 个项目`, 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    addLogEntry(`批量删除失败: ${error.message}`, 'error');
    showStatus(`批量删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 批量移动项目
function batchMoveItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要移动的项目', 'warning');
    return;
  }
  
  // 加载目标文件夹选项
  loadMoveTargetFolders();
  
  // 显示移动模态框
  document.getElementById('move-modal').classList.remove('hidden');
  
  addLogEntry(`准备批量移动 ${selectedBookmarks.size} 个项目`, 'info');
}

// 加载移动目标文件夹
function loadMoveTargetFolders() {
  const select = document.getElementById('target-folder');
  select.innerHTML = '';
  
  // 递归添加文件夹选项
  function addFolderOptions(nodes, level = 0) {
    nodes.forEach(node => {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = '  '.repeat(level) + (node.title || '无标题文件夹');
        select.appendChild(option);
        
        // 递归添加子文件夹
        addFolderOptions(node.children, level + 1);
      }
    });
  }
  
  addFolderOptions(bookmarkTreeData);
}

// 确认批量移动
async function confirmMoveItems() {
  const targetFolderId = document.getElementById('target-folder').value;
  
  if (!targetFolderId) {
    showStatus('请选择目标文件夹', 'warning');
    return;
  }
  
  try {
    showLoading(true);
    addLogEntry(`开始批量移动 ${selectedBookmarks.size} 个项目到目标文件夹...`, 'info');
    
    let movedCount = 0;
    const selectedArray = Array.from(selectedBookmarks);
    
    for (const nodeId of selectedArray) {
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.move(nodeId, { parentId: targetFolderId }, (result) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(result);
            }
          });
        });
        
        movedCount++;
        
      } catch (error) {
        addLogEntry(`移动项目 ${nodeId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`批量移动完成，成功移动 ${movedCount} 个项目`, 'success');
    showStatus(`批量移动完成，成功移动 ${movedCount} 个项目`, 'success');
    
    // 关闭模态框并刷新
    closeMoveModal();
    await refreshBookmarkManager();
    
  } catch (error) {
    addLogEntry(`批量移动失败: ${error.message}`, 'error');
    showStatus(`批量移动失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 关闭移动模态框
function closeMoveModal() {
  document.getElementById('move-modal').classList.add('hidden');
}

// 批量导出项目
function batchExportItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要导出的项目', 'warning');
    return;
  }
  
  try {
    const exportData = [];
    const selectedArray = Array.from(selectedBookmarks);
    
    selectedArray.forEach(nodeId => {
      const node = findNodeById(nodeId);
      if (node) {
        exportData.push({
          id: node.id,
          title: node.title,
          url: node.url,
          parentId: node.parentId,
          type: node.url ? 'bookmark' : 'folder'
        });
      }
    });
    
    // 创建CSV内容
    let csvContent = '类型,标题,URL,ID,父文件夹ID\n';
    exportData.forEach(item => {
      const type = item.type === 'bookmark' ? '书签' : '文件夹';
      const title = `"${(item.title || '').replace(/"/g, '""')}"`;
      const url = `"${(item.url || '').replace(/"/g, '""')}"`;
      csvContent += `${type},${title},${url},${item.id},${item.parentId}\n`;
    });
    
    // 下载文件
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    const fileName = `选中书签_${new Date().toISOString().slice(0, 10)}.csv`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`成功导出 ${exportData.length} 个选中项目`, 'success');
    showStatus(`导出成功: ${fileName}`, 'success');
    
  } catch (error) {
    addLogEntry(`批量导出失败: ${error.message}`, 'error');
    showStatus(`导出失败: ${error.message}`, 'error');
  }
}

// 查找节点by ID
function findNodeById(nodeId) {
  function searchNode(nodes) {
    if (!nodes || !Array.isArray(nodes)) {
      return null;
    }
    
    for (const node of nodes) {
      if (node.id === nodeId) {
        addLogEntry(`找到节点: ${node.title} (ID: ${node.id})`, 'info');
        return node;
      }
      if (node.children && Array.isArray(node.children)) {
        const found = searchNode(node.children);
        if (found) return found;
      }
    }
    return null;
  }
  
  try {
    const result = searchNode(bookmarkTreeData);
    if (!result) {
      addLogEntry(`警告: 未找到ID为 ${nodeId} 的节点`, 'warning');
    }
    return result;
  } catch (error) {
    addLogEntry(`查找节点时出错: ${error.message}`, 'error');
    return null;
  }
}

// ======== 导入导出功能 ========

// 导入书签
function importBookmarks() {
  // 触发文件选择
  document.getElementById('bookmark-file-input').click();
}

// 处理文件导入
async function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  addLogEntry(`开始导入文件: ${file.name}`, 'info');
  showLoading(true);
  
  try {
    const fileContent = await readFileContent(file);
    
    if (file.name.endsWith('.json')) {
      await importJsonBookmarks(fileContent);
    } else if (file.name.endsWith('.html')) {
      await importHtmlBookmarks(fileContent);
    } else {
      throw new Error('不支持的文件格式，请选择JSON或HTML文件');
    }
    
  } catch (error) {
    addLogEntry(`导入文件失败: ${error.message}`, 'error');
    showStatus(`导入失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
    // 清空文件输入
    event.target.value = '';
  }
}

// 读取文件内容
function readFileContent(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.onerror = () => reject(new Error('文件读取失败'));
    reader.readAsText(file, 'utf-8');
  });
}

// 导入JSON格式书签
async function importJsonBookmarks(jsonContent) {
  try {
    const bookmarkData = JSON.parse(jsonContent);
    
    if (!Array.isArray(bookmarkData)) {
      throw new Error('JSON格式不正确，应为书签数组');
    }
    
    let importedCount = 0;
    const targetFolderId = '2'; // 其他书签文件夹
    
    for (const bookmark of bookmarkData) {
      if (bookmark.url && bookmark.title) {
        try {
          await new Promise((resolve, reject) => {
            chrome.bookmarks.create({
              parentId: targetFolderId,
              title: bookmark.title,
              url: bookmark.url
            }, (result) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve(result);
              }
            });
          });
          
          importedCount++;
        } catch (error) {
          addLogEntry(`导入书签"${bookmark.title}"失败: ${error.message}`, 'warning');
        }
      }
    }
    
    addLogEntry(`JSON导入完成，成功导入 ${importedCount} 个书签`, 'success');
    showStatus(`导入成功: ${importedCount} 个书签`, 'success');
    
    // 刷新书签管理器
    if (document.getElementById('bookmark-manager-container').classList.contains('hidden') === false) {
      await refreshBookmarkManager();
    }
    
  } catch (error) {
    throw new Error(`JSON解析失败: ${error.message}`);
  }
}

// 导入HTML格式书签
async function importHtmlBookmarks(htmlContent) {
  try {
    // 创建临时DOM来解析HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    const bookmarkLinks = doc.querySelectorAll('a[href]');
    let importedCount = 0;
    const targetFolderId = '2'; // 其他书签文件夹
    
    for (const link of bookmarkLinks) {
      const url = link.getAttribute('href');
      const title = link.textContent.trim();
      
      if (url && title) {
        try {
          await new Promise((resolve, reject) => {
            chrome.bookmarks.create({
              parentId: targetFolderId,
              title: title,
              url: url
            }, (result) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve(result);
              }
            });
          });
          
          importedCount++;
        } catch (error) {
          addLogEntry(`导入书签"${title}"失败: ${error.message}`, 'warning');
        }
      }
    }
    
    addLogEntry(`HTML导入完成，成功导入 ${importedCount} 个书签`, 'success');
    showStatus(`导入成功: ${importedCount} 个书签`, 'success');
    
    // 刷新书签管理器
    if (document.getElementById('bookmark-manager-container').classList.contains('hidden') === false) {
      await refreshBookmarkManager();
    }
    
  } catch (error) {
    throw new Error(`HTML解析失败: ${error.message}`);
  }
}

// 备份书签
async function backupBookmarks() {
  addLogEntry('开始备份所有书签...', 'info');
  showLoading(true);
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    
    // 创建备份数据
    const backupData = {
      timestamp: new Date().toISOString(),
      version: '1.0',
      bookmarkCount: allBookmarks.length,
      bookmarks: allBookmarks
    };
    
    // 创建JSON文件
    const jsonContent = JSON.stringify(backupData, null, 2);
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    const fileName = `书签备份_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`备份完成，共备份 ${allBookmarks.length} 个书签`, 'success');
    showStatus(`备份成功: ${fileName}`, 'success');
    
  } catch (error) {
    addLogEntry(`备份失败: ${error.message}`, 'error');
    showStatus(`备份失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 将关键函数暴露到全局作用域，以便onclick事件处理器可以访问
window.editBookmarkItem = editBookmarkItem;
window.deleteBookmarkItem = deleteBookmarkItem;
window.toggleNodeExpansion = toggleNodeExpansion;
window.toggleBookmarkSelection = toggleBookmarkSelection;

// 添加调试和诊断功能
window.debugBookmarkManager = function() {
  console.log('=== 书签管理器调试信息 ===');
  
  // 1. 检查Chrome API
  console.log('1. Chrome API检查:');
  console.log('- chrome:', !!chrome);
  console.log('- chrome.bookmarks:', !!chrome?.bookmarks);
  console.log('- chrome.bookmarks.getTree:', typeof chrome?.bookmarks?.getTree);
  
  // 2. 检查DOM元素
  console.log('2. DOM元素检查:');
  const managerContainer = document.getElementById('bookmark-manager-container');
  const treeContainer = document.getElementById('bookmark-tree');
  console.log('- bookmark-manager-container:', !!managerContainer, managerContainer?.classList?.contains('hidden') ? '隐藏' : '显示');
  console.log('- bookmark-tree:', !!treeContainer);
  
  // 3. 检查数据状态
  console.log('3. 数据状态检查:');
  console.log('- bookmarkTreeData:', !!bookmarkTreeData, bookmarkTreeData?.length || 0);
  console.log('- selectedBookmarks:', selectedBookmarks?.size || 0);
  
  // 4. 尝试获取书签数据
  console.log('4. 尝试获取书签数据:');
  if (chrome?.bookmarks?.getTree) {
    chrome.bookmarks.getTree((nodes) => {
      if (chrome.runtime.lastError) {
        console.error('获取书签失败:', chrome.runtime.lastError);
      } else {
        console.log('成功获取书签树:', nodes);
        const stats = analyzeBookmarkTree(nodes);
        console.log('书签统计:', stats);
      }
    });
  }
  
  // 5. 检查渲染的节点
  console.log('5. 渲染节点检查:');
  const renderedNodes = document.querySelectorAll('.tree-node');
  console.log('- 渲染的节点数:', renderedNodes.length);
  
  if (renderedNodes.length > 0) {
    console.log('- 前5个节点的详情:');
    Array.from(renderedNodes).slice(0, 5).forEach((node, index) => {
      const title = node.querySelector('.tree-title')?.textContent;
      const nodeId = node.dataset.nodeId;
      console.log(`  ${index + 1}. "${title}" (ID: ${nodeId})`);
    });
  }
  
  // 6. 检查事件绑定
  console.log('6. 事件绑定检查:');
  const editButtons = document.querySelectorAll('.edit-btn');
  const deleteButtons = document.querySelectorAll('.delete-btn');
  console.log('- 编辑按钮数:', editButtons.length);
  console.log('- 删除按钮数:', deleteButtons.length);
  
  // 7. 检查扩展权限
  console.log('7. 扩展权限检查:');
  chrome.permissions?.getAll?.((permissions) => {
    console.log('- 当前权限:', permissions);
  });
  
  console.log('=== 调试信息结束 ===');
  
  return {
    chromeApi: !!chrome?.bookmarks,
    domElements: {
      managerContainer: !!managerContainer,
      treeContainer: !!treeContainer
    },
    data: {
      bookmarkTreeData: !!bookmarkTreeData,
      selectedBookmarks: selectedBookmarks?.size || 0
    },
    renderedNodes: renderedNodes.length
  };
};

// 自动书签管理器修复函数
window.fixBookmarkManager = async function() {
  console.log('开始自动修复书签管理器...');
  addLogEntry('启动书签管理器自动修复程序...', 'info');
  
  try {
    // 1. 重新加载数据
    addLogEntry('步骤1: 重新加载书签数据...', 'info');
    await loadBookmarkTree();
    
    // 2. 重新渲染界面
    addLogEntry('步骤2: 重新渲染界面...', 'info');
    renderBookmarkTree();
    
    // 3. 自动展开主要文件夹
    addLogEntry('步骤3: 自动展开主要文件夹...', 'info');
    setTimeout(() => {
      expandFirstLevelFolders();
      expandAllFolders(true); // 展开所有文件夹以确保用户能看到所有书签
    }, 500);
    
    // 4. 验证修复结果
    setTimeout(() => {
      const renderedNodes = document.querySelectorAll('.tree-node');
      const visibleNodes = document.querySelectorAll('.tree-node:not(.tree-children.hidden .tree-node)');
      
      addLogEntry(`修复完成! 共渲染 ${renderedNodes.length} 个节点，其中 ${visibleNodes.length} 个可见`, 'success');
      
      if (renderedNodes.length === 0) {
        addLogEntry('警告: 没有渲染任何节点，可能存在数据问题', 'warning');
      }
    }, 1000);
    
  } catch (error) {
    addLogEntry(`自动修复失败: ${error.message}`, 'error');
    throw error;
  }
};

console.log('书签管理器调试功能已加载。使用 debugBookmarkManager() 查看调试信息，使用 fixBookmarkManager() 尝试自动修复。');

// ======== 拖拽排序功能 ========

// 开始拖拽
function handleDragStart(e) {
  draggedElement = e.target;
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', e.target.outerHTML);
  
  // 添加拖拽样式
  e.target.classList.add('dragging');
  
  addLogEntry(`开始拖拽: ${draggedElement.querySelector('.tree-title').textContent}`, 'info');
}

// 拖拽悬停
function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  
  const target = e.currentTarget;
  if (target !== draggedElement && target.classList.contains('tree-node')) {
    // 显示放置指示器
    target.classList.add('drag-over');
  }
}

// 处理放置
async function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  
  const target = e.currentTarget;
  target.classList.remove('drag-over');
  
  if (target === draggedElement || !draggedElement) {
    return;
  }
  
  try {
    const draggedNodeId = draggedElement.dataset.nodeId;
    const targetNodeId = target.dataset.nodeId;
    const targetNodeType = target.dataset.nodeType;
    
    if (targetNodeType === 'folder') {
      // 移动到文件夹内
      await moveBookmarkToFolder(draggedNodeId, targetNodeId);
      addLogEntry(`成功将项目移动到文件夹中`, 'success');
    } else {
      // 重新排序 - 将拖拽项目移动到目标项目之前
      await reorderBookmarks(draggedNodeId, targetNodeId);
      addLogEntry(`成功重新排序书签`, 'success');
    }
    
    // 刷新管理器
    await refreshBookmarkManager();
    showStatus('拖拽操作完成', 'success');
    
  } catch (error) {
    addLogEntry(`拖拽操作失败: ${error.message}`, 'error');
    showStatus(`拖拽失败: ${error.message}`, 'error');
  }
}

// 结束拖拽
function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  
  // 清除所有拖拽样式
  document.querySelectorAll('.drag-over').forEach(el => {
    el.classList.remove('drag-over');
  });
  
  draggedElement = null;
}

// 移动书签到文件夹
async function moveBookmarkToFolder(bookmarkId, folderId) {
  return new Promise((resolve, reject) => {
    chrome.bookmarks.move(bookmarkId, { parentId: folderId }, (result) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else {
        resolve(result);
      }
    });
  });
}

// 重新排序书签
async function reorderBookmarks(sourceId, targetId) {
  try {
    // 获取目标书签的信息
    const targetNode = findNodeById(targetId);
    if (!targetNode) {
      throw new Error('找不到目标书签');
    }
    
    // 获取目标书签的索引
    const parentId = targetNode.parentId;
    const siblings = await new Promise((resolve, reject) => {
      chrome.bookmarks.getChildren(parentId, (children) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(children);
        }
      });
    });
    
    const targetIndex = siblings.findIndex(child => child.id === targetId);
    
    // 移动源书签到目标位置
    await new Promise((resolve, reject) => {
      chrome.bookmarks.move(sourceId, { 
        parentId: parentId, 
        index: targetIndex 
      }, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
  } catch (error) {
    throw new Error(`重新排序失败: ${error.message}`);
  }
}

// ======== 内联编辑功能 ========

// 开始内联编辑
function startInlineEdit(titleElement, node) {
  if (inlineEditingElement) {
    // 如果已有其他元素在编辑，先完成编辑
    const existingInput = document.querySelector('.tree-title-edit:not(.hidden)');
    if (existingInput) {
      existingInput.blur();
    }
  }
  
  const titleContainer = titleElement.parentElement;
  const editInput = titleContainer.querySelector('.tree-title-edit');
  
  // 显示输入框，隐藏标题
  titleElement.classList.add('hidden');
  editInput.classList.remove('hidden');
  editInput.value = titleElement.textContent;
  editInput.focus();
  editInput.select();
  
  inlineEditingElement = editInput;
  
  addLogEntry(`开始内联编辑: ${node.title}`, 'info');
}

// 完成内联编辑
async function finishInlineEdit(editInput, titleElement, node) {
  const newTitle = editInput.value.trim();
  
  if (!newTitle) {
    cancelInlineEdit(editInput, titleElement);
    showStatus('标题不能为空', 'error');
    return;
  }
  
  if (newTitle === titleElement.textContent) {
    // 没有更改
    cancelInlineEdit(editInput, titleElement);
    return;
  }
  
  try {
    // 更新书签标题
    await new Promise((resolve, reject) => {
      chrome.bookmarks.update(node.id, { title: newTitle }, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
    // 更新UI
    titleElement.textContent = newTitle;
    titleElement.dataset.originalTitle = newTitle;
    
    // 隐藏输入框，显示标题
    editInput.classList.add('hidden');
    titleElement.classList.remove('hidden');
    
    inlineEditingElement = null;
    
    addLogEntry(`成功重命名为: ${newTitle}`, 'success');
    showStatus('重命名成功', 'success');
    
  } catch (error) {
    addLogEntry(`重命名失败: ${error.message}`, 'error');
    showStatus(`重命名失败: ${error.message}`, 'error');
    cancelInlineEdit(editInput, titleElement);
  }
}

// 取消内联编辑
function cancelInlineEdit(editInput, titleElement) {
  editInput.classList.add('hidden');
  titleElement.classList.remove('hidden');
  editInput.value = titleElement.textContent;
  inlineEditingElement = null;
}

// ======== 批量重命名功能 ========

// 切换批量重命名模式
function toggleBatchRenameMode() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要重命名的项目', 'warning');
    return;
  }
  
  batchEditMode = !batchEditMode;
  
  if (batchEditMode) {
    // 进入批量重命名模式
    enableBatchRenameMode();
  } else {
    // 退出批量重命名模式
    disableBatchRenameMode();
  }
}

// 启用批量重命名模式
function enableBatchRenameMode() {
  addLogEntry(`启用批量重命名模式，选中 ${selectedBookmarks.size} 个项目`, 'info');
  
  // 为所有选中的项目添加重命名输入框
  selectedBookmarks.forEach(nodeId => {
    const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
    if (nodeElement) {
      const titleElement = nodeElement.querySelector('.tree-title');
      const titleContainer = titleElement.parentElement;
      
      // 创建批量重命名输入框
      let batchInput = titleContainer.querySelector('.batch-rename-input');
      if (!batchInput) {
        batchInput = document.createElement('input');
        batchInput.type = 'text';
        batchInput.className = 'batch-rename-input';
        batchInput.value = titleElement.textContent;
        batchInput.dataset.nodeId = nodeId;
        batchInput.dataset.originalTitle = titleElement.textContent;
        titleContainer.appendChild(batchInput);
      }
      
      // 显示输入框，隐藏标题
      titleElement.classList.add('hidden');
      batchInput.classList.remove('hidden');
      
      // 添加批量重命名样式
      nodeElement.classList.add('batch-rename-mode');
    }
  });
  
  // 更新UI
  updateBatchRenameUI(true);
  showStatus(`批量重命名模式已启用，共 ${selectedBookmarks.size} 个项目`, 'info');
}

// 禁用批量重命名模式
function disableBatchRenameMode() {
  // 移除所有批量重命名输入框
  document.querySelectorAll('.batch-rename-input').forEach(input => {
    const titleContainer = input.parentElement;
    const titleElement = titleContainer.querySelector('.tree-title');
    
    // 恢复标题显示
    titleElement.classList.remove('hidden');
    input.remove();
  });
  
  // 移除批量重命名样式
  document.querySelectorAll('.batch-rename-mode').forEach(el => {
    el.classList.remove('batch-rename-mode');
  });
  
  // 更新UI
  updateBatchRenameUI(false);
  batchEditMode = false;
  
  addLogEntry('退出批量重命名模式', 'info');
  showStatus('已退出批量重命名模式', 'info');
}

// 更新批量重命名UI
function updateBatchRenameUI(enabled) {
  const batchRenameBtn = document.getElementById('batch-rename');
  const saveBatchBtn = document.getElementById('save-batch-rename');
  const cancelBatchBtn = document.getElementById('cancel-batch-rename');
  
  if (enabled) {
    batchRenameBtn.textContent = '🔄 退出重命名';
    batchRenameBtn.classList.add('active');
    if (saveBatchBtn) saveBatchBtn.classList.remove('hidden');
    if (cancelBatchBtn) cancelBatchBtn.classList.remove('hidden');
  } else {
    batchRenameBtn.textContent = '📝 批量重命名';
    batchRenameBtn.classList.remove('active');
    if (saveBatchBtn) saveBatchBtn.classList.add('hidden');
    if (cancelBatchBtn) cancelBatchBtn.classList.add('hidden');
  }
}

// 保存批量重命名
async function saveBatchRenames() {
  const batchInputs = document.querySelectorAll('.batch-rename-input');
  
  if (batchInputs.length === 0) {
    showStatus('没有要保存的重命名项目', 'warning');
    return;
  }
  
  try {
    showLoading(true);
    let successCount = 0;
    let errorCount = 0;
    
    addLogEntry(`开始保存 ${batchInputs.length} 个项目的重命名...`, 'info');
    
    for (const input of batchInputs) {
      const nodeId = input.dataset.nodeId;
      const originalTitle = input.dataset.originalTitle;
      const newTitle = input.value.trim();
      
      if (!newTitle) {
        addLogEntry(`跳过空标题项目: ${originalTitle}`, 'warning');
        errorCount++;
        continue;
      }
      
      if (newTitle === originalTitle) {
        // 没有更改，跳过
        continue;
      }
      
      try {
        await new Promise((resolve, reject) => {
// 全局变量
let bookmarks = [];
let categories = {};
let apiStatus = false;
let processingBatch = false;
let currentBatchIndex = 0;
let batchSize = 50;
let totalBookmarksCount = 0;
let logVisible = false;
const MAX_LOG_ENTRIES = 500; // 最大日志条目数
let bookmarkWorker = null; // Web Worker引用

// 书签管理器相关变量
let bookmarkTreeData = [];
let selectedBookmarks = new Set();
let currentEditingItem = null;
let draggedElement = null; // 拖拽元素
let inlineEditingElement = null; // 内联编辑元素
let batchEditMode = false; // 批量编辑模式

// 初始化分析页面
document.addEventListener('DOMContentLoaded', () => {
  // 初始化Web Worker
  initializeWorker();
  
  // 获取API状态
  checkApiStatus();
  
  // 添加按钮事件监听
  document.getElementById('analyze-bookmarks').addEventListener('click', analyzeBookmarks);
  document.getElementById('cancel-analyze').addEventListener('click', cancelAnalyze);
  document.getElementById('organize-bookmarks').addEventListener('click', organizeBookmarks);
  document.getElementById('export-bookmarks').addEventListener('click', exportBookmarks);
  document.getElementById('setup-api').addEventListener('click', openOptions);
  document.getElementById('view-history').addEventListener('click', openHistoryPage);
  
  // 添加新功能的事件监听器
  document.getElementById('detect-duplicates').addEventListener('click', detectDuplicateBookmarks);
  document.getElementById('detect-invalid').addEventListener('click', detectInvalidBookmarks);
  document.getElementById('cleanup-bookmarks').addEventListener('click', cleanupBookmarks);
  document.getElementById('manage-bookmarks').addEventListener('click', openBookmarkManager);
  document.getElementById('import-bookmarks').addEventListener('click', importBookmarks);
  document.getElementById('backup-bookmarks').addEventListener('click', backupBookmarks);
  
  // 书签管理器相关事件监听器
  document.getElementById('expand-all-folders').addEventListener('click', () => expandAllFolders(true));
  document.getElementById('collapse-all-folders').addEventListener('click', () => expandAllFolders(false));
  document.getElementById('create-folder').addEventListener('click', createNewFolder);
  document.getElementById('refresh-manager').addEventListener('click', refreshBookmarkManager);
  
  // 批量操作事件监听器
  document.getElementById('batch-delete').addEventListener('click', batchDeleteItems);
  document.getElementById('batch-move').addEventListener('click', batchMoveItems);
  document.getElementById('batch-export').addEventListener('click', batchExportItems);
  document.getElementById('select-all-bookmarks').addEventListener('click', () => selectAllBookmarks(true));
  document.getElementById('deselect-all-bookmarks').addEventListener('click', () => selectAllBookmarks(false));
  
  // 添加新的批量操作事件监听器
  document.getElementById('batch-rename').addEventListener('click', toggleBatchRenameMode);
  document.getElementById('save-batch-rename').addEventListener('click', saveBatchRenames);
  document.getElementById('cancel-batch-rename').addEventListener('click', cancelBatchRename);
  
  // 模态框事件监听器
  document.getElementById('modal-close').addEventListener('click', closeEditModal);
  document.getElementById('cancel-edit').addEventListener('click', closeEditModal);
  document.getElementById('save-edit').addEventListener('click', saveBookmarkEdit);
  document.getElementById('move-modal-close').addEventListener('click', closeMoveModal);
  document.getElementById('cancel-move').addEventListener('click', closeMoveModal);
  document.getElementById('confirm-move').addEventListener('click', confirmMoveItems);
  
  // 检测结果操作事件监听器
  document.getElementById('remove-duplicates').addEventListener('click', removeDuplicateBookmarks);
  document.getElementById('remove-invalid').addEventListener('click', removeInvalidBookmarks);
  document.getElementById('remove-empty-folders').addEventListener('click', removeEmptyFolders);
  document.getElementById('select-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', true));
  document.getElementById('deselect-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', false));
  document.getElementById('select-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', true));
  document.getElementById('deselect-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', false));
  document.getElementById('select-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', true));
  document.getElementById('deselect-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', false));
  
  // 文件导入事件监听器
  document.getElementById('bookmark-file-input').addEventListener('change', handleFileImport);
  
  // 添加日志控制按钮事件监听
  document.getElementById('toggle-log').addEventListener('click', toggleLogVisibility);
  document.getElementById('clear-log').addEventListener('click', clearLog);
  
  // 添加可视化切换事件
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.addEventListener('click', switchVisualizationTab);
  });
  
  // 添加窗口关闭事件，终止Worker
  window.addEventListener('beforeunload', terminateWorker);
});

// 初始化Web Worker
function initializeWorker() {
  try {
    // 确保之前的worker已终止
    if (bookmarkWorker) {
      bookmarkWorker.terminate();
    }
    
    // 创建新Worker
    bookmarkWorker = new Worker('bookmarkProcessor.js');
    
    // 设置消息处理
    bookmarkWorker.onmessage = handleWorkerMessage;
    bookmarkWorker.onerror = handleWorkerError;
    
    addLogEntry('Web Worker初始化成功 - 启用后台处理以提高性能', 'success');
  } catch (error) {
    console.error('无法初始化Web Worker:', error);
    addLogEntry('无法初始化Web Worker, 将使用主线程处理 - ' + error.message, 'warning');
  }
}

// 处理Worker消息
function handleWorkerMessage(e) {
  const { action, ...data } = e.data;
  
  switch (action) {
    case 'process-bookmarks-result':
      console.log('收到Worker处理的书签数据', data.processedBookmarks.length);
      // 处理Worker返回的预处理书签数据
      break;
      
    case 'merge-categories-result':
      categories = data.mergedCategories;
      console.log('分类已在Worker中合并', Object.keys(categories).length);
      displayCategories(categories, 20);
      break;
      
    case 'error':
      console.error('Worker错误:', data.error);
      addLogEntry(`Worker处理出错: ${data.error}`, 'error');
      break;
      
    default:
      console.log('未处理的Worker消息:', action, data);
  }
}

// 处理Worker错误
function handleWorkerError(error) {
  console.error('Worker运行错误:', error);
  addLogEntry(`Worker运行错误: ${error.message}`, 'error');
}

// 终止Worker
function terminateWorker() {
  if (bookmarkWorker) {
    bookmarkWorker.terminate();
    bookmarkWorker = null;
  }
}

// 切换日志可见性
function toggleLogVisibility() {
  const logContainer = document.getElementById('log-container');
  logVisible = !logVisible;
  
  if (logVisible) {
    logContainer.classList.remove('hidden');
  } else {
    logContainer.classList.add('hidden');
  }
}

// 清空日志
function clearLog() {
  document.getElementById('log-entries').innerHTML = '';
}

// 添加日志条目
function addLogEntry(message, type = 'info') {
  const logContainer = document.getElementById('log-entries');
  
  // 限制日志条目数量，避免内存占用过大
  const entries = logContainer.querySelectorAll('.log-entry');
  if (entries.length >= MAX_LOG_ENTRIES) {
    // 移除最早的20%日志条目
    const removeCount = Math.ceil(MAX_LOG_ENTRIES * 0.2);
    for (let i = 0; i < removeCount; i++) {
      if (logContainer.firstChild) {
        logContainer.removeChild(logContainer.firstChild);
      }
    }
    // 添加一条提示信息
    if (logContainer.firstChild === logContainer.querySelector('.log-entry-trimmed')) {
      // 已经有提示，不重复添加
    } else {
      const trimNotice = document.createElement('div');
      trimNotice.className = 'log-entry log-entry-trimmed warning';
      trimNotice.textContent = `为提高性能，已移除 ${removeCount} 条较早的日志...`;
      logContainer.insertBefore(trimNotice, logContainer.firstChild);
    }
  }
  
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  
  // 添加时间戳
  const timeStamp = new Date().toLocaleTimeString();
  const timeSpan = document.createElement('span');
  timeSpan.className = 'log-entry-time';
  timeSpan.textContent = `[${timeStamp}]`;
  
  entry.appendChild(timeSpan);
  entry.appendChild(document.createTextNode(` ${message}`));
  
  // 添加到日志容器
  logContainer.appendChild(entry);
  
  // 自动滚动到底部
  logContainer.scrollTop = logContainer.scrollHeight;
  
  // 如果日志不可见且是重要信息，自动显示
  if (!logVisible && (type === 'error' || type === 'warning')) {
    toggleLogVisibility();
  }
  
  // 同时在控制台记录
  console.log(`[${type}] ${message}`);
}

// 检查API连接状态
function checkApiStatus() {
  chrome.storage.sync.get(['apiProvider', 'apiKey'], (result) => {
    const apiStatusElement = document.getElementById('api-status');
    
    if (result.apiProvider && result.apiKey) {
      apiStatus = true;
      apiStatusElement.textContent = '已连接';
      apiStatusElement.className = 'api-connected';
      addLogEntry(`API状态：已连接 (提供商: ${result.apiProvider})`, 'success');
    } else {
      apiStatus = false;
      apiStatusElement.textContent = '未连接';
      apiStatusElement.className = 'api-not-connected';
      addLogEntry('API状态：未连接，请先在设置中配置API', 'warning');
    }
  });
}

// 打开选项页面
function openOptions() {
  chrome.runtime.openOptionsPage();
}

// 分析书签
async function analyzeBookmarks() {
  if (!apiStatus) {
    showStatus('请先在设置中配置API连接', 'error');
    addLogEntry('API未连接，请先在设置中配置API连接', 'error');
    return;
  }
  
  // 清空之前的日志
  clearLog();
  
  // 显示加载动画和进度条
  showLoading(true);
  showProgress(true);
  showStatus('正在获取书签...');
  addLogEntry('开始书签分析过程...', 'info');
  
  // 显示取消按钮，隐藏分析按钮
  toggleAnalyzeButtons(true);
  
  try {
    // 重置状态
    categories = {};
    currentBatchIndex = 0;
    processingBatch = false;
    
    // 获取所有书签
    addLogEntry('正在获取所有书签...', 'info');
    bookmarks = await getAllBookmarks();
    totalBookmarksCount = bookmarks.length;
    
    // 添加标签层级统计
    addLogEntry('开始分析书签结构...', 'info');
    const folderStructure = {};
    
    bookmarks.forEach(bookmark => {
      if (bookmark.parentId) {
        folderStructure[bookmark.parentId] = folderStructure[bookmark.parentId] || [];
        folderStructure[bookmark.parentId].push(bookmark.id);
      }
    });
    
    // 统计书签所在的文件夹分布
    const folderDistribution = Object.entries(folderStructure)
      .map(([folderId, bookmarkIds]) => ({
        folderId,
        count: bookmarkIds.length
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
    
    addLogEntry('书签文件夹分布(TOP5):', 'info');
    folderDistribution.forEach(folder => {
      addLogEntry(`  - 文件夹ID ${folder.folderId}: 包含${folder.count}个书签`, 'info');
    });
    
    addLogEntry(`成功获取 ${totalBookmarksCount} 个书签`, 'success');
    showStatus(`已获取 ${totalBookmarksCount} 个书签，正在分批分析...`);
    
    // 获取API设置和批处理大小
    addLogEntry('正在获取API设置...', 'info');
    const settings = await getApiSettings();
    batchSize = settings.batchSize;
    
    addLogEntry(`API提供商: ${settings.provider}, 模型: ${settings.model}`, 'info');
    addLogEntry(`批处理大小: ${batchSize}`, 'info');
    
    // 开始批处理
    processingBatch = true;
    addLogEntry('开始批量处理书签...', 'info');
    await processBatches(settings);
    
  } catch (error) {
    console.error('分析书签时出错:', error);
    addLogEntry(`分析出错: ${error.message}`, 'error');
    showStatus(`分析出错: ${error.message}`, 'error');
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 取消分析
function cancelAnalyze() {
  processingBatch = false;
  addLogEntry('用户请求取消分析，正在中断处理...', 'warning');
  showStatus('正在取消分析...');
}

// 切换分析/取消按钮
function toggleAnalyzeButtons(isProcessing) {
  const analyzeButton = document.getElementById('analyze-bookmarks');
  const cancelButton = document.getElementById('cancel-analyze');
  
  if (isProcessing) {
    analyzeButton.classList.add('hidden');
    cancelButton.classList.remove('hidden');
  } else {
    analyzeButton.classList.remove('hidden');
    cancelButton.classList.add('hidden');
  }
}

// 更新进度条
function updateProgress(current, total) {
  const progressBar = document.getElementById('progress-bar');
  const percentage = Math.min(Math.round((current / total) * 100), 100);
  progressBar.style.width = `${percentage}%`;
}

// 批量处理书签
async function processBatches(settings) {
  try {
    const totalBatches = Math.ceil(bookmarks.length / batchSize);
    addLogEntry(`总共将分成 ${totalBatches} 个批次处理`, 'info');
    
    // 记录内存使用情况
    if (window.performance && window.performance.memory) {
      const memoryInfo = window.performance.memory;
      addLogEntry(`初始内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`, 'info');
    }
    
    while (currentBatchIndex < totalBatches && processingBatch) {
      const startIdx = currentBatchIndex * batchSize;
      const endIdx = Math.min(startIdx + batchSize, bookmarks.length);
      const currentBatch = bookmarks.slice(startIdx, endIdx);
      
      // 更新进度条
      updateProgress(startIdx, bookmarks.length);
      
      const batchInfo = `批次 ${currentBatchIndex + 1}/${totalBatches} (${startIdx + 1}-${endIdx}/${totalBookmarksCount})`;
      showStatus(`正在处理第 ${currentBatchIndex + 1}/${totalBatches} 批书签 (${startIdx + 1}-${endIdx}/${totalBookmarksCount})...`);
      addLogEntry(`开始处理${batchInfo}`, 'info');
      
      // 等待一小段时间让UI更新
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // 分类当前批次的书签
      addLogEntry(`正在调用API对${batchInfo}进行分类...`, 'info');
      const startTime = Date.now();
      
      // 使用try-catch单独处理每批，避免一批失败影响整体
      try {
        const batchCategories = await categorizeBookmarks(currentBatch, settings);
        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        // 记录分类结果
        const categoryCount = Object.keys(batchCategories).length;
        addLogEntry(`${batchInfo}分类完成，用时${elapsedTime}秒，分为${categoryCount}个类别`, 'success');
        
        // 打印每个类别的书签数量（仅打印前10个类别，避免日志过多）
        const categoriesToLog = Object.entries(batchCategories).slice(0, 10);
        categoriesToLog.forEach(([category, items]) => {
          addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
        });
        
        if (Object.keys(batchCategories).length > 10) {
          addLogEntry(`  - ... 以及 ${Object.keys(batchCategories).length - 10} 个其他类别`, 'info');
        }
        
        // 合并分类结果
        addLogEntry(`正在合并${batchInfo}分类结果...`, 'info');
        mergeCategoryResults(batchCategories);
        
      } catch (batchError) {
        addLogEntry(`处理${batchInfo}时出错: ${batchError.message}，跳过此批次`, 'error');
        console.error(`批次处理错误:`, batchError);
      }
      
      // 批次处理完成后，等待一段时间让UI刷新，防止浏览器卡死
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 限制显示类别数量，避免DOM过度膨胀
      displayCategories(categories, 20);
      
      // 每处理3批，手动触发垃圾回收并清理不再需要的数据
      if (currentBatchIndex % 3 === 0) {
        addLogEntry('执行内存优化...', 'info');
        
        // 清除当前批次的临时变量
        const currentBatch = null;
        
        // 在后台任务中执行昂贵的清理操作
        setTimeout(() => {
          // 提示浏览器进行垃圾回收
          if (window.gc) {
            try {
              window.gc();
            } catch (e) {
              // 忽略，某些浏览器不支持手动垃圾回收
            }
          }
          
          // 记录内存使用情况
          if (window.performance && window.performance.memory) {
            const memoryInfo = window.performance.memory;
            console.log(`当前内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`);
          }
        }, 0);
      }
      
      // 更新进度
      currentBatchIndex++;
    }
    
    // 更新到100%
    updateProgress(bookmarks.length, bookmarks.length);
    
    if (processingBatch) {
      // 全部处理完成
      const finalCategories = Object.keys(categories).length;
      showStatus(`分析完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      addLogEntry(`分析全部完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      
      // 保存分析历史版本
      await saveBookmarkHistory();
      
      // 生成可视化图表
      generateVisualizations();
      
      // 释放内存
      setTimeout(() => {
        addLogEntry('正在优化内存使用...', 'info');
        // 仅保留必要数据
        bookmarks = bookmarks.map(bookmark => ({
          id: bookmark.id,
          title: bookmark.title,
          url: bookmark.url,
          parentId: bookmark.parentId
        }));
        
        // 提示浏览器进行垃圾回收
        if (window.gc) {
          try {
            window.gc();
          } catch (e) {
            // 忽略
          }
        }
      }, 1000);
      
      // 显示最终分类统计（限制数量）
      const topCategories = Object.entries(categories)
        .sort((a, b) => b[1].length - a[1].length)
        .slice(0, 20);
      
      topCategories.forEach(([category, items]) => {
        addLogEntry(`${category}: ${items.length}个书签`, 'success');
      });
      
      if (Object.keys(categories).length > 20) {
        addLogEntry(`... 以及 ${Object.keys(categories).length - 20} 个其他类别`, 'success');
      }
      
      // 完成后显示全部分类
      displayCategories(categories);
    } else {
      // 用户取消了处理
      showStatus('书签分析已中断', 'error');
      addLogEntry('书签分析被用户中断', 'warning');
    }
  } catch (error) {
    console.error('批处理书签时出错:', error);
    showStatus(`批处理出错: ${error.message}`, 'error');
    addLogEntry(`批处理出错: ${error.message}`, 'error');
  } finally {
    processingBatch = false;
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 使用Worker合并分类结果
function mergeCategoryResults(batchCategories) {
  // 检查Worker是否可用
  if (bookmarkWorker) {
    try {
      // 通过Worker合并分类
      bookmarkWorker.postMessage({
        action: 'merge-categories',
        data: {
          existingCategories: categories,
          newCategories: batchCategories
        }
      });
      return; // Worker会异步更新categories
    } catch (error) {
      console.error('Worker合并分类失败，回退到主线程:', error);
      addLogEntry('Worker处理失败，切换至主线程', 'warning');
    }
  }
  
  // 回退到主线程处理
  for (const [category, items] of Object.entries(batchCategories)) {
    if (!categories[category]) {
      categories[category] = [];
    }
    
    categories[category] = categories[category].concat(items);
  }
}

// 获取所有书签
function getAllBookmarks() {
  return new Promise((resolve) => {
    chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      const bookmarks = [];
      
      // 添加调试信息
      addLogEntry(`开始获取书签树...`, 'info');
      console.log('书签树根节点:', bookmarkTreeNodes);
      
      // 递归函数，遍历书签树
      function processNode(node) {
        // 如果是书签（有url属性）
        if (node.url) {
          // 记录原始书签数据，用于调试
          console.log('处理书签:', { id: node.id, title: node.title, url: node.url });
          
          // 添加标签信息到日志
          addLogEntry(`获取书签: ID=${node.id}, 标题="${node.title}", URL=${node.url.substring(0, 30)}...`, 'info');
          
          // 验证并处理标题
          let processedTitle = node.title || '';
          // 如果标题为空或只包含数字，尝试从URL生成更有意义的标题
          if (!processedTitle || /^\d+$/.test(processedTitle)) {
            try {
              const url = new URL(node.url);
              // 使用主机名作为标题的一部分
              processedTitle = url.hostname.replace(/^www\./, '');
              addLogEntry(`发现无效书签标题(${node.title})，已自动替换为: ${processedTitle}`, 'warning');
            } catch (e) {
              // URL解析失败，保留原标题
              processedTitle = node.title || '未命名书签';
            }
          }
          
          bookmarks.push({
            id: node.id,
            title: processedTitle,
            url: node.url,
            parentId: node.parentId,
            originalTitle: node.title // 保存原始标题以便比较
          });
        }
        
        // 如果是文件夹，记录文件夹信息
        if (!node.url && node.title) {
          addLogEntry(`发现书签文件夹: ID=${node.id}, 标题="${node.title}"`, 'info');
        }
        
        // 如果有子节点，继续处理
        if (node.children) {
          addLogEntry(`处理文件夹"${node.title || '根目录'}"的${node.children.length}个子项`, 'info');
          for (const child of node.children) {
            processNode(child);
          }
        }
      }
      
      // 从根节点开始处理
      for (const node of bookmarkTreeNodes) {
        processNode(node);
      }
      
      // 添加调试信息
      const emptyTitles = bookmarks.filter(b => !b.title).length;
      const numericTitles = bookmarks.filter(b => /^\d+$/.test(b.title)).length;
      addLogEntry(`书签获取完成: 总计${bookmarks.length}个书签, ${emptyTitles}个空标题, ${numericTitles}个纯数字标题`, 'info');
      
      // 添加更详细的分类统计
      const domainMap = {};
      bookmarks.forEach(bookmark => {
        try {
          const url = new URL(bookmark.url);
          const domain = url.hostname.replace(/^www\./, '');
          domainMap[domain] = (domainMap[domain] || 0) + 1;
        } catch (e) {
          // 忽略无效URL
        }
      });
      
      // 输出前10个最常见的域名
      const topDomains = Object.entries(domainMap)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (topDomains.length > 0) {
        addLogEntry(`最常见的域名:`, 'info');
        topDomains.forEach(([domain, count]) => {
          addLogEntry(`  - ${domain}: ${count}个书签`, 'info');
        });
      }
      
      resolve(bookmarks);
    });
  });
}

// 获取API设置
function getApiSettings() {
  return new Promise((resolve) => {
    chrome.storage.sync.get([
      'apiProvider', 
      'apiKey', 
      'customApiUrl', 
      'geminiModel', 
      'openaiModel', 
      'customModel', 
      'defaultCategories', 
      'batchSize'
    ], (result) => {
      const apiProvider = result.apiProvider || 'gemini';
      let model = '';
      
      // 根据提供商选择对应的模型
      switch (apiProvider) {
        case 'gemini':
          model = result.geminiModel || 'gemini-2.0-flash';
          break;
        case 'openai':
          model = result.openaiModel || 'gpt-3.5-turbo';
          break;
        case 'custom':
          model = result.customModel || '';
          break;
      }
      
      resolve({
        provider: apiProvider,
        apiKey: result.apiKey || '',
        customApiUrl: result.customApiUrl || '',
        model: model,
        defaultCategories: result.defaultCategories || '技术,教育,购物,社交媒体,新闻,娱乐,工作,其他',
        batchSize: result.batchSize || 50
      });
    });
  });
}

// 使用AI对书签进行分类
async function categorizeBookmarks(bookmarks, settings) {
  // 增强预处理：检查并修复书签数据
  addLogEntry(`开始预处理书签数据...`, 'info');
  
  // 统计有效书签数量
  const validBookmarks = bookmarks.filter(b => b.title && b.url).length;
  const totalBookmarks = bookmarks.length;
  if (validBookmarks < totalBookmarks) {
    addLogEntry(`警告: 检测到${totalBookmarks - validBookmarks}个无效书签 (无标题或URL)`, 'warning');
  }
  
  // 标签长度统计
  const titleLengths = bookmarks.map(b => b.title ? b.title.length : 0);
  const avgTitleLength = titleLengths.reduce((sum, len) => sum + len, 0) / titleLengths.length || 0;
  const maxTitleLength = Math.max(...titleLengths);
  const minTitleLength = Math.min(...(titleLengths.filter(len => len > 0) || [0]));
  
  addLogEntry(`标签标题统计: 平均长度=${avgTitleLength.toFixed(1)}字符, 最长=${maxTitleLength}字符, 最短=${minTitleLength}字符`, 'info');
  
  // 检查常见的特殊标签
  const specialPatterns = {
    '纯数字标题': /^\d+$/,
    '包含特殊字符': /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/,
    '非中文标题': /^[^\u4e00-\u9fa5]+$/,
    '过长标题(>30字符)': title => title.length > 30
  };
  
  const specialStats = {};
  Object.keys(specialPatterns).forEach(key => {
    specialStats[key] = 0;
  });
  
  bookmarks.forEach(bookmark => {
    if (bookmark.title) {
      Object.entries(specialPatterns).forEach(([key, pattern]) => {
        if (typeof pattern === 'function') {
          if (pattern(bookmark.title)) specialStats[key]++;
        } else if (pattern.test(bookmark.title)) {
          specialStats[key]++;
        }
      });
    }
  });
  
  addLogEntry(`标签特征统计:`, 'info');
  Object.entries(specialStats).forEach(([key, count]) => {
    const percentage = ((count / totalBookmarks) * 100).toFixed(1);
    addLogEntry(`  - ${key}: ${count}个 (${percentage}%)`, 'info');
  });
  
  // 预处理：创建更友好的数据集
  const bookmarkData = bookmarks.map(b => {
    // 尝试从URL提取域名作为附加信息
    let domain = '';
    try {
      if (b.url) {
        const urlObj = new URL(b.url);
        domain = urlObj.hostname.replace(/^www\./, '');
      }
    } catch (e) {
      // URL解析失败，忽略
    }
    
    return {
      title: b.title || domain || '未命名书签',
      url: b.url || '',
      domain: domain
    };
  });
  
  // 简单自动分类：尝试预先识别一些常见类别
  const preCategorized = {};
  const domainPatterns = {
    // AI工具和服务
    '通用AI工具': [/gemini\.google\.com/, /openai\.com/, /chat\.openai\.com/, /perplexity\.ai/, /claude\.ai/, /poe\.com/],
    'AI开发平台': [/aistudio\.google\.com/, /platform\.openai\.com/, /colab\.research\.google/, /huggingface\.co/],
    'AI笔记工具': [/notebooklm\.google\.com/, /notion\.ai/, /obsidian\.md/],
    
    // 设计工具和平台
    'UI设计工具': [/figma\.com/, /sketch\.com/, /adobe\.com/, /canva\.com/, /framer\.com/],
    '原型设计': [/gamma\.app/, /miro\.com/, /whimsical\.com/, /mockplus\.com/, /axure\.com/],
    '开发设计工具': [/lovable\.dev/, /v0\.dev/, /bolt\.new/, /replit\.com/, /codesandbox\.io/],
    
    // 教程和学习资源
    'UI设计教程': [/uisdc\.com/, /uxdesign\.cc/, /dribbble\.com/, /behance\.net/, /designbetter\.co/],
    '技术教程': [/csdn\.net/, /juejin\.cn/, /segmentfault\.com/, /dev\.to/, /medium\.com/],
    '在线课程': [/coursera\.org/, /udemy\.com/, /edx\.org/, /khan.*academy/, /freecodecamp\.org/],
    
    // 开发工具
    '代码托管': [/github\.com/, /gitlab\.com/, /gitee\.com/, /bitbucket\.org/],
    '技术问答': [/stackoverflow\.com/, /stackexchange\.com/, /zhihu\.com/],
    '文档工具': [/gitbook\.com/, /docsify\.js\.org/, /vuepress\.vuejs\.org/],
    
    // 实用工具
    '翻译工具': [/translate\.google\.com/, /deepl\.com/, /fanyi\.baidu\.com/, /youdao\.com/],
    '图片工具': [/tinypng\.com/, /remove\.bg/, /unsplash\.com/, /pexels\.com/],
    '在线办公': [/docs\.google\.com/, /office\.com/, /notion\.so/, /airtable\.com/],
    
    // 传统分类（保留但细化）
    '视频娱乐': [/youtube\.com/, /bilibili\.com/, /netflix\.com/, /youku\.com/, /iqiyi\.com/],
    '社交媒体': [/twitter\.com/, /facebook\.com/, /instagram\.com/, /weibo\.com/, /linkedin\.com/, /reddit\.com/],
    '电商购物': [/taobao\.com/, /jd\.com/, /amazon\.com/, /tmall\.com/, /pinduoduo\.com/],
    '邮箱服务': [/mail\./, /gmail\.com/, /outlook\.com/, /qq\.com.*mail/],
    '新闻资讯': [/news\./, /sina\.com/, /qq\.com/, /163\.com/, /bbc\./, /cnn\./]
  };
  
  // 基于书签标题的关键词匹配（增强识别能力）
  const titleKeywords = {
    'AI工具教程': ['AI教程', 'ChatGPT教程', 'Gemini使用', '人工智能教程', 'AI学习', 'machine learning'],
    'UI设计素材': ['设计素材', 'UI素材', '图标', 'icon', '配色', 'color', '字体', 'font'],
    'UI设计案例': ['设计案例', 'UI案例', '界面设计', '交互设计', 'UX案例', '设计灵感'],
    'Figma教程': ['Figma', 'figma教程', '组件库', 'design system'],
    '游戏UI设计': ['游戏UI', '游戏界面', 'game ui', 'game design'],
    '前端开发': ['前端', 'frontend', 'Vue', 'React', 'Angular', 'JavaScript'],
    '后端开发': ['后端', 'backend', 'API', 'Node.js', 'Python', 'Java'],
    '移动开发': ['移动开发', 'iOS', 'Android', 'Flutter', 'React Native']
  };
  
  // 尝试做一些预分类，帮助AI更好理解
  bookmarkData.forEach(bookmark => {
    let categorized = false;
    
    // 首先尝试域名匹配
    for (const [category, patterns] of Object.entries(domainPatterns)) {
      if (patterns.some(pattern => pattern.test(bookmark.domain || bookmark.url))) {
        if (!preCategorized[category]) {
          preCategorized[category] = [];
        }
        preCategorized[category].push(bookmark);
        categorized = true;
        break; // 一个书签只归入一个预分类
      }
    }
    
    // 如果域名没有匹配到，尝试标题关键词匹配
    if (!categorized && bookmark.title) {
      const title = bookmark.title.toLowerCase();
      for (const [category, keywords] of Object.entries(titleKeywords)) {
        if (keywords.some(keyword => title.includes(keyword.toLowerCase()))) {
          if (!preCategorized[category]) {
            preCategorized[category] = [];
          }
          preCategorized[category].push(bookmark);
          break;
        }
      }
    }
  });
  
  // 输出预分类结果
  addLogEntry(`预分类结果:`, 'info');
  Object.entries(preCategorized).forEach(([category, items]) => {
    addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
  });
  
  // 统计未被预分类的书签数量
  const preCategorizedCount = Object.values(preCategorized).reduce((sum, items) => sum + items.length, 0);
  const uncategorizedCount = bookmarkData.length - preCategorizedCount;
  addLogEntry(`预分类统计: 已分类${preCategorizedCount}个 (${((preCategorizedCount/bookmarkData.length)*100).toFixed(1)}%), 未分类${uncategorizedCount}个`, 'info');
  
  // 添加预分类信息到提示词中，帮助AI更好地理解
  const preCategorizedInfo = Object.entries(preCategorized)
    .map(([category, items]) => `- ${category}: ${items.length}个书签，例如: ${items.slice(0, 3).map(b => b.title).join(', ')}...`)
    .join('\n');
  
  // 构建提示词
  const prompt = `你是一个专业的书签分类助手。请对以下书签进行详细分类，创建有意义且细致的分类体系。

分类指导原则：
1. 分类数量：鼓励创建10-25个细分类别，根据书签内容的丰富程度灵活调整
2. 分类细度：优先创建细致、专业的分类，而不是宽泛的大类
3. 分类名称：使用准确、专业的中文词汇，体现具体用途或领域
4. 禁止使用：数字(0,1,2...)、字母(A,B,C...)或特殊符号作为分类名
5. 输出格式：严格JSON格式，不添加其他说明文字

建议的细分类别示例（根据实际内容调整）：
- AI工具类：通用AI工具、AI开发平台、AI笔记工具、AI工具教程
- 设计类：UI设计工具、原型设计、UI设计教程、UI设计素材、设计案例、Figma教程
- 开发类：代码托管、技术教程、前端开发、后端开发、技术问答
- 实用工具：翻译工具、图片工具、在线办公
- 学习资源：在线课程、技术文档、设计学习

${preCategorizedInfo ? `参考预分类（可进一步细分或调整）：\n${preCategorizedInfo}\n` : ''}

请根据书签的具体内容和用途，创建尽可能准确和细致的分类：

输出格式：
{
  "通用AI工具": [
    {"title": "Gemini", "url": "https://gemini.google.com/app"},
    {"title": "Perplexity", "url": "https://www.perplexity.ai/"}
  ],
  "AI开发平台": [
    {"title": "Google AI Studio", "url": "https://aistudio.google.com/"}
  ],
  "UI设计教程": [
    {"title": "Figma组件库教程", "url": "https://www.uisdc.com/..."}
  ]
}

需要分类的书签：
${JSON.stringify(bookmarkData, null, 2)}`;

  // 根据API提供商选择合适的处理方法
  let categoryResult;
  try {
    addLogEntry(`开始调用AI进行书签分类...`, 'info');
    
    switch (settings.provider) {
      case 'gemini':
        categoryResult = await callGeminiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'openai':
        categoryResult = await callOpenAiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'custom':
        categoryResult = await callCustomApi(settings.apiKey, settings.customApiUrl, settings.model, prompt);
        break;
      default:
        throw new Error('不支持的API提供商');
    }
    
    addLogEntry(`AI分类完成，获得${Object.keys(categoryResult).length}个分类`, 'success');
    
    // 分析分类质量
    const categoryNames = Object.keys(categoryResult);
    const numericCategories = categoryNames.filter(name => /^\d+$/.test(name)).length;
    const shortCategories = categoryNames.filter(name => name.length < 2).length;
    const longCategories = categoryNames.filter(name => name.length > 10).length;
    
    addLogEntry(`分类质量分析:`, 'info');
    addLogEntry(`  - 纯数字分类: ${numericCategories}个`, numericCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过短分类(小于2字符): ${shortCategories}个`, shortCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过长分类(大于10字符): ${longCategories}个`, longCategories > 0 ? 'info' : 'info');
    
    // 如果API返回空结果或没有分类，尝试使用预分类结果
    if (!categoryResult || Object.keys(categoryResult).length === 0) {
      addLogEntry('API返回的分类结果为空，尝试使用预分类结果', 'warning');
      
      if (Object.keys(preCategorized).length > 0) {
        categoryResult = preCategorized;
        addLogEntry(`使用预分类结果: ${Object.keys(preCategorized).length}个分类`, 'info');
      } else {
        // 创建一个基本分类
        categoryResult = { "未分类": bookmarkData };
        addLogEntry(`无法获取有效分类，所有书签归为"未分类"`, 'error');
      }
    }
    
    // 验证并优化分类结果
    return validateAndOptimizeCategories(categoryResult, bookmarks.length);
  } catch (error) {
    console.error('分类处理失败:', error);
    addLogEntry(`分类处理失败: ${error.message}，尝试使用备用方案`, 'error');
    
    // 出错时使用预分类作为备用方案
    if (Object.keys(preCategorized).length > 0) {
      // 将未预分类的书签放入"其他"分类
      const uncategorized = bookmarkData.filter(bookmark => {
        return !Object.values(preCategorized).some(items => 
          items.some(item => item.url === bookmark.url)
        );
      });
      
      if (uncategorized.length > 0) {
        preCategorized["其他"] = uncategorized;
      }
      
      addLogEntry(`使用预分类作为备用方案: ${Object.keys(preCategorized).length}个分类`, 'info');
      return preCategorized;
    }
    
    // 如果没有预分类，使用基本分类
    const basicCategories = {
      "常用网站": bookmarkData.slice(0, Math.min(20, bookmarkData.length)),
      "其他书签": bookmarkData.slice(Math.min(20, bookmarkData.length))
    };
    
    addLogEntry(`无法进行分类，使用基本分类方案`, 'warning');
    return basicCategories;
  }
}

// 验证并优化分类结果
function validateAndOptimizeCategories(categories, totalBookmarks) {
  // 提高分类数量限制，鼓励细分
  const MAX_CATEGORIES = 30; // 从20提高到30
  let categoriesCount = Object.keys(categories).length;
  
  // 只有在分类数量严重超标时才进行合并
  if (categoriesCount > MAX_CATEGORIES) {
    addLogEntry(`分类数量(${categoriesCount})超过最大限制(${MAX_CATEGORIES})，正在适度优化...`, 'warning');
    
    // 获取所有分类及其书签数量
    const categoriesWithCount = Object.entries(categories)
      .map(([name, items]) => ({ name, count: items.length }))
      .sort((a, b) => b.count - a.count);
    
    // 保留前25个分类，只合并极小的分类（少于等于1个书签的）
    const mainCategories = categoriesWithCount.slice(0, MAX_CATEGORIES - 5);
    const smallCategories = categoriesWithCount.slice(MAX_CATEGORIES - 5);
    
    // 只合并真正的小分类（1个书签的分类）
    const verySmallCategories = smallCategories.filter(cat => cat.count <= 1);
    const keepCategories = smallCategories.filter(cat => cat.count > 1);
    
    // 创建新的分类结果
    const optimizedCategories = {};
    
    // 添加主要分类
    mainCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 保留有意义的小分类（超过1个书签）
    keepCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 只合并极小的分类
    if (verySmallCategories.length > 0) {
      optimizedCategories["其他"] = optimizedCategories["其他"] || [];
      verySmallCategories.forEach(cat => {
        optimizedCategories["其他"] = optimizedCategories["其他"].concat(categories[cat.name]);
      });
      addLogEntry(`已将${verySmallCategories.length}个单书签分类合并到"其他"`, 'info');
    }
    
    return optimizedCategories;
  }
  
  // 验证分类名称，修复纯数字或无意义的分类名
  const optimizedCategories = {};
  const numericPattern = /^[\d]+$/;  // 匹配纯数字
  
  Object.entries(categories).forEach(([categoryName, items]) => {
    let newName = categoryName;
    
    // 检查是否为纯数字或太短的分类名
    if (numericPattern.test(categoryName) || categoryName.length < 2) {
      // 尝试根据内容推断更好的名称
      newName = inferCategoryName(items) || "其他";
      addLogEntry(`已修正无效的分类名"${categoryName}"为"${newName}"`, 'warning');
    }
    
    // 添加到优化后的分类
    if (!optimizedCategories[newName]) {
      optimizedCategories[newName] = [];
    }
    optimizedCategories[newName] = optimizedCategories[newName].concat(items);
  });
  
  addLogEntry(`分类验证完成，保留${Object.keys(optimizedCategories).length}个分类`, 'success');
  
  return optimizedCategories;
}

// 尝试根据书签内容推断分类名称
function inferCategoryName(bookmarks) {
  // 常见网站类型映射
  const domainCategories = {
    'github.com': '程序开发',
    'youtube.com': '视频娱乐',
    'bilibili.com': '视频娱乐',
    'zhihu.com': '问答社区',
    'taobao.com': '网上购物',
    'jd.com': '网上购物',
    'tmall.com': '网上购物',
    'weibo.com': '社交媒体',
    'twitter.com': '社交媒体',
    'facebook.com': '社交媒体',
    'instagram.com': '社交媒体',
    'linkedin.com': '职业社交',
    'stackoverflow.com': '技术问答',
    'mail.': '电子邮箱',
    'gmail': '电子邮箱',
    'outlook': '电子邮箱',
    'docs.google.com': '在线办公',
    'notion.so': '在线办公',
    'edu.': '教育学习',
    'csdn.net': '技术博客',
    'juejin.cn': '技术博客',
    'medium.com': '博客平台'
  };
  
  // 提取所有书签的域名
  const domains = bookmarks.map(bm => {
    try {
      if (!bm.url) return '';
      const urlObj = new URL(bm.url);
      return urlObj.hostname;
    } catch {
      return '';
    }
  }).filter(Boolean);
  
  // 尝试找出最常见的域名类型
  const categoryMatches = {};
  
  domains.forEach(domain => {
    for (const [pattern, category] of Object.entries(domainCategories)) {
      if (domain.includes(pattern)) {
        categoryMatches[category] = (categoryMatches[category] || 0) + 1;
      }
    }
  });
  
  // 找出匹配最多的分类
  let bestCategory = null;
  let maxMatches = 0;
  
  for (const [category, matches] of Object.entries(categoryMatches)) {
    if (matches > maxMatches) {
      maxMatches = matches;
      bestCategory = category;
    }
  }
  
  // 如果有超过20%的书签匹配同一个分类，使用该分类
  if (bestCategory && maxMatches >= domains.length * 0.2) {
    return bestCategory;
  }
  
  // 没有找到合适的分类
  return null;
}

// 共享的JSON解析和修复函数
function parseJsonWithRecovery(jsonStr) {
  // 首先尝试直接解析
  try {
    const result = JSON.parse(jsonStr);
    return result;
  } catch (firstError) {
    addLogEntry(`初次JSON解析失败: ${firstError.message}`, 'warning');
    
    // 尝试修复常见的JSON错误
    let fixedJson = jsonStr;
    
    // 修复1: 移除可能的前导/尾随文本
    const cleanMatch = fixedJson.match(/{[\s\S]*}/);
    if (cleanMatch) {
      fixedJson = cleanMatch[0];
    }
    
    // 修复2: 处理不完整的JSON（添加缺失的大括号或方括号）
    const openBraces = (fixedJson.match(/{/g) || []).length;
    const closeBraces = (fixedJson.match(/}/g) || []).length;
    const openBrackets = (fixedJson.match(/\[/g) || []).length;
    const closeBrackets = (fixedJson.match(/]/g) || []).length;
    
    // 添加缺失的闭合括号
    for (let i = 0; i < openBraces - closeBraces; i++) {
      fixedJson += '}';
    }
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      fixedJson += ']';
    }
    
    // 修复3: 处理尾部逗号
    fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1');
    
    // 修复4: 处理缺失的引号
    fixedJson = fixedJson.replace(/(\w+):/g, '"$1":');
    
    addLogEntry(`尝试修复后的JSON: ${fixedJson.substring(0, 100)}...`, 'info');
    
    try {
      return JSON.parse(fixedJson);
    } catch (secondError) {
      addLogEntry(`JSON修复后仍然解析失败: ${secondError.message}`, 'error');
      
      // 作为最后的手段，尝试提取键值对并构建基本结构
      try {
        const fallbackResult = {};
        const keyValueMatches = fixedJson.match(/"([^"]+)":\s*\[([^\]]*)\]/g);
        
        if (keyValueMatches && keyValueMatches.length > 0) {
          addLogEntry(`尝试从键值对构建JSON结构...`, 'warning');
          
          keyValueMatches.forEach(match => {
            const kvMatch = match.match(/"([^"]+)":\s*\[([^\]]*)\]/);
            if (kvMatch) {
              const category = kvMatch[1];
              const content = kvMatch[2];
              
              // 尝试解析书签对象
              const bookmarks = [];
              const bookmarkMatches = content.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/g);
              
              if (bookmarkMatches) {
                bookmarkMatches.forEach(bmMatch => {
                  const bmParts = bmMatch.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/);
                  if (bmParts) {
                    bookmarks.push({
                      title: bmParts[1],
                      url: bmParts[2]
                    });
                  }
                });
              }
              
              if (bookmarks.length > 0) {
                fallbackResult[category] = bookmarks;
              }
            }
          });
          
          if (Object.keys(fallbackResult).length > 0) {
            addLogEntry(`成功从键值对构建了${Object.keys(fallbackResult).length}个分类`, 'success');
            return fallbackResult;
          }
        }
      } catch (fallbackError) {
        addLogEntry(`备用解析方案也失败了: ${fallbackError.message}`, 'error');
      }
      
      // 如果所有尝试都失败了，抛出原始错误
      throw new Error(`JSON解析失败，已尝试多种修复方案: ${firstError.message}`);
    }
  }
}

// 通用JSON提取函数
function extractJsonFromText(responseText) {
  addLogEntry(`正在从响应中提取JSON数据...`, 'info');
  
  // 多种JSON提取策略
  let jsonText = '';
  
  // 策略1: 寻找完整的JSON代码块
  const codeBlockMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                         responseText.match(/```\s*([\s\S]*?)\s*```/);
  
  if (codeBlockMatch) {
    jsonText = codeBlockMatch[1].trim();
    addLogEntry(`从代码块中提取JSON，长度: ${jsonText.length}字符`, 'success');
  } else {
    // 策略2: 寻找第一个完整的JSON对象
    const jsonObjectMatch = responseText.match(/{[\s\S]*}/);
    if (jsonObjectMatch) {
      jsonText = jsonObjectMatch[0];
      addLogEntry(`从文本中提取JSON对象，长度: ${jsonText.length}字符`, 'success');
    } else {
      // 策略3: 使用整个响应
      jsonText = responseText.trim();
      addLogEntry(`未找到JSON格式标记，使用整个响应作为JSON`, 'warning');
    }
  }
  
  return jsonText;
}

// 调用Gemini API
async function callGeminiApi(prompt, apiKey, model) {
  try {
    // 构建URL，注意版本号
    const apiVersion = model.startsWith('gemini-1.5') ? 'v1' : 'v1beta';
    const url = `https://generativelanguage.googleapis.com/${apiVersion}/models/${model}:generateContent?key=${apiKey}`;
    
    console.log(`正在调用Gemini API，模型: ${model}`);
    addLogEntry(`正在调用Gemini API，模型: ${model}`, 'info');
    
    // 记录发送的数据，用于调试
    const requestData = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048
      }
    };
    
    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);
    
    addLogEntry(`发送请求到: ${apiVersion} 版本API...`, 'info');
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('Gemini API错误响应:', errorData);
      addLogEntry(`Gemini API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    addLogEntry(`Gemini API请求成功，正在处理响应...`, 'info');
    const data = await response.json();
    
    // 检查响应格式
    if (!data.candidates || data.candidates.length === 0) {
      console.error('Gemini API返回无效数据:', data);
      addLogEntry(`Gemini API返回无效数据，没有candidates`, 'error');
      throw new Error('API返回数据无效，没有candidates');
    }
    
    // 提取响应文本
    const responseText = data.candidates[0].content.parts[0].text;
    addLogEntry(`成功获取API响应，内容长度: ${responseText.length}字符`, 'success');
    
    // 保存完整响应以便调试
    console.log('API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('Gemini API调用出错:', error);
    addLogEntry(`Gemini API调用失败: ${error.message}`, 'error');
    throw new Error(`Gemini API调用失败: ${error.message}`);
  }
}

// 调用OpenAI API
async function callOpenAiApi(prompt, apiKey, model) {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'system',
            content: '你是一个书签分类助手，请将用户提供的书签分类，并以JSON格式返回。'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3
      })
    });
    
    if (!response.ok) {
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // 提取响应文本
    const responseText = data.choices[0].message.content;
    addLogEntry(`成功获取OpenAI API响应，内容长度: ${responseText.length}字符`, 'success');
    console.log('OpenAI API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      addLogEntry(`OpenAI JSON解析成功，包含${categoryNames.length}个分类`, 'success');
      
      return result;
    } catch (jsonError) {
      console.error('OpenAI JSON解析失败:', jsonError);
      addLogEntry(`OpenAI JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('OpenAI API调用出错:', error);
    throw new Error(`OpenAI API调用失败: ${error.message}`);
  }
}

// 调用自定义API分析书签
async function callCustomApi(apiKey, customApiUrl, model, prompt) {
  try {
    console.log('调用自定义API，URL:', customApiUrl);
    addLogEntry(`正在调用自定义API，模型: ${model}`, 'info');
    
    // 准备请求内容 - 提供多种可能的消息格式，增加兼容性
    const requestData = {
      model: model,
      prompt: prompt,
      message: prompt,
      // 兼容更多API格式
      messages: [
        { role: "user", content: prompt }
      ],
      content: prompt,
      input: prompt
    };

    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);

    addLogEntry(`发送请求到自定义API...`, 'info');
    const response = await fetch(customApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify(requestData)
    });

    const responseData = await response.json();
    if (!response.ok) {
      console.error('自定义API错误响应:', responseData);
      addLogEntry(`自定义API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API响应错误: ${response.status} - ${JSON.stringify(responseData)}`);
    }

    addLogEntry(`自定义API请求成功，正在处理响应...`, 'info');
    console.log('API完整响应:', responseData);

    // 处理不同格式的API响应，提取文本内容
    let resultText = '';
    
    // 1. 直接返回字符串
    if (typeof responseData === 'string') {
      resultText = responseData;
    }
    // 2. 有标准字段的情况
    else if (responseData.text || responseData.content || responseData.message || responseData.response) {
      resultText = responseData.text || responseData.content || responseData.message || responseData.response;
    }
    // 3. OpenAI格式
    else if (responseData.choices && responseData.choices.length > 0) {
      resultText = responseData.choices[0].text || responseData.choices[0].message?.content;
    }
    // 4. 有result字段的情况
    else if (responseData.result) {
      if (typeof responseData.result === 'string') {
        resultText = responseData.result;
      } else {
        // 如果result是对象，可能直接就是分类结果
        console.log('检测到result字段为对象，直接返回:', responseData.result);
        addLogEntry(`检测到result字段为对象，直接返回`, 'info');
        return responseData.result;
      }
    }
    // 5. 整个响应就是结果
    else {
      console.log('未找到标准结果字段，尝试使用整个响应');
      addLogEntry(`未找到标准结果字段，尝试使用整个响应`, 'warning');
      resultText = JSON.stringify(responseData);
    }

    if (!resultText) {
      throw new Error('无法从API响应中提取文本内容');
    }

    addLogEntry(`成功获取API响应，内容长度: ${resultText.length}字符`, 'success');
    console.log('提取的响应文本:', resultText);

    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(resultText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用共享的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('自定义API调用出错:', error);
    addLogEntry(`自定义API调用失败: ${error.message}`, 'error');
    throw new Error(`自定义API调用失败: ${error.message}`);
  }
}

// 显示分类结果
function displayCategories(categories, maxCategories = Infinity) {
  const resultsContainer = document.getElementById('results');
  resultsContainer.innerHTML = '';
  
  // 记录详细分类结果到日志
  addLogEntry(`开始显示分类结果...`, 'info');
  addLogEntry(`总共有 ${Object.keys(categories).length} 个分类`, 'info');
  
  // 优化：如果类别太多，按大小排序并限制显示数量
// 全局变量
let bookmarks = [];
let categories = {};
let apiStatus = false;
let processingBatch = false;
let currentBatchIndex = 0;
let batchSize = 50;
let totalBookmarksCount = 0;
let logVisible = false;
const MAX_LOG_ENTRIES = 500; // 最大日志条目数
let bookmarkWorker = null; // Web Worker引用

// 书签管理器相关变量
let bookmarkTreeData = [];
let selectedBookmarks = new Set();
let currentEditingItem = null;
let draggedElement = null; // 拖拽元素
let inlineEditingElement = null; // 内联编辑元素
let batchEditMode = false; // 批量编辑模式

// 初始化分析页面
document.addEventListener('DOMContentLoaded', () => {
  // 初始化Web Worker
  initializeWorker();
  
  // 获取API状态
  checkApiStatus();
  
  // 添加按钮事件监听
  document.getElementById('analyze-bookmarks').addEventListener('click', analyzeBookmarks);
  document.getElementById('cancel-analyze').addEventListener('click', cancelAnalyze);
  document.getElementById('organize-bookmarks').addEventListener('click', organizeBookmarks);
  document.getElementById('export-bookmarks').addEventListener('click', exportBookmarks);
  document.getElementById('setup-api').addEventListener('click', openOptions);
  document.getElementById('view-history').addEventListener('click', openHistoryPage);
  
  // 添加新功能的事件监听器
  document.getElementById('detect-duplicates').addEventListener('click', detectDuplicateBookmarks);
  document.getElementById('detect-invalid').addEventListener('click', detectInvalidBookmarks);
  document.getElementById('cleanup-bookmarks').addEventListener('click', cleanupBookmarks);
  document.getElementById('manage-bookmarks').addEventListener('click', openBookmarkManager);
  document.getElementById('import-bookmarks').addEventListener('click', importBookmarks);
  document.getElementById('backup-bookmarks').addEventListener('click', backupBookmarks);
  
  // 书签管理器相关事件监听器
  document.getElementById('expand-all-folders').addEventListener('click', () => expandAllFolders(true));
  document.getElementById('collapse-all-folders').addEventListener('click', () => expandAllFolders(false));
  document.getElementById('create-folder').addEventListener('click', createNewFolder);
  document.getElementById('refresh-manager').addEventListener('click', refreshBookmarkManager);
  
  // 批量操作事件监听器
  document.getElementById('batch-delete').addEventListener('click', batchDeleteItems);
  document.getElementById('batch-move').addEventListener('click', batchMoveItems);
  document.getElementById('batch-export').addEventListener('click', batchExportItems);
  document.getElementById('select-all-bookmarks').addEventListener('click', () => selectAllBookmarks(true));
  document.getElementById('deselect-all-bookmarks').addEventListener('click', () => selectAllBookmarks(false));
  
  // 添加新的批量操作事件监听器
  document.getElementById('batch-rename').addEventListener('click', toggleBatchRenameMode);
  document.getElementById('save-batch-rename').addEventListener('click', saveBatchRenames);
  document.getElementById('cancel-batch-rename').addEventListener('click', cancelBatchRename);
  
  // 模态框事件监听器
  document.getElementById('modal-close').addEventListener('click', closeEditModal);
  document.getElementById('cancel-edit').addEventListener('click', closeEditModal);
  document.getElementById('save-edit').addEventListener('click', saveBookmarkEdit);
  document.getElementById('move-modal-close').addEventListener('click', closeMoveModal);
  document.getElementById('cancel-move').addEventListener('click', closeMoveModal);
  document.getElementById('confirm-move').addEventListener('click', confirmMoveItems);
  
  // 检测结果操作事件监听器
  document.getElementById('remove-duplicates').addEventListener('click', removeDuplicateBookmarks);
  document.getElementById('remove-invalid').addEventListener('click', removeInvalidBookmarks);
  document.getElementById('remove-empty-folders').addEventListener('click', removeEmptyFolders);
  document.getElementById('select-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', true));
  document.getElementById('deselect-all-duplicates').addEventListener('click', () => selectAllDetectionItems('duplicates', false));
  document.getElementById('select-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', true));
  document.getElementById('deselect-all-invalid').addEventListener('click', () => selectAllDetectionItems('invalid', false));
  document.getElementById('select-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', true));
  document.getElementById('deselect-all-empty-folders').addEventListener('click', () => selectAllDetectionItems('empty-folders', false));
  
  // 文件导入事件监听器
  document.getElementById('bookmark-file-input').addEventListener('change', handleFileImport);
  
  // 添加日志控制按钮事件监听
  document.getElementById('toggle-log').addEventListener('click', toggleLogVisibility);
  document.getElementById('clear-log').addEventListener('click', clearLog);
  
  // 添加可视化切换事件
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.addEventListener('click', switchVisualizationTab);
  });
  
  // 添加窗口关闭事件，终止Worker
  window.addEventListener('beforeunload', terminateWorker);
});

// 初始化Web Worker
function initializeWorker() {
  try {
    // 确保之前的worker已终止
    if (bookmarkWorker) {
      bookmarkWorker.terminate();
    }
    
    // 创建新Worker
    bookmarkWorker = new Worker('bookmarkProcessor.js');
    
    // 设置消息处理
    bookmarkWorker.onmessage = handleWorkerMessage;
    bookmarkWorker.onerror = handleWorkerError;
    
    addLogEntry('Web Worker初始化成功 - 启用后台处理以提高性能', 'success');
  } catch (error) {
    console.error('无法初始化Web Worker:', error);
    addLogEntry('无法初始化Web Worker, 将使用主线程处理 - ' + error.message, 'warning');
  }
}

// 处理Worker消息
function handleWorkerMessage(e) {
  const { action, ...data } = e.data;
  
  switch (action) {
    case 'process-bookmarks-result':
      console.log('收到Worker处理的书签数据', data.processedBookmarks.length);
      // 处理Worker返回的预处理书签数据
      break;
      
    case 'merge-categories-result':
      categories = data.mergedCategories;
      console.log('分类已在Worker中合并', Object.keys(categories).length);
      displayCategories(categories, 20);
      break;
      
    case 'error':
      console.error('Worker错误:', data.error);
      addLogEntry(`Worker处理出错: ${data.error}`, 'error');
      break;
      
    default:
      console.log('未处理的Worker消息:', action, data);
  }
}

// 处理Worker错误
function handleWorkerError(error) {
  console.error('Worker运行错误:', error);
  addLogEntry(`Worker运行错误: ${error.message}`, 'error');
}

// 终止Worker
function terminateWorker() {
  if (bookmarkWorker) {
    bookmarkWorker.terminate();
    bookmarkWorker = null;
  }
}

// 切换日志可见性
function toggleLogVisibility() {
  const logContainer = document.getElementById('log-container');
  logVisible = !logVisible;
  
  if (logVisible) {
    logContainer.classList.remove('hidden');
  } else {
    logContainer.classList.add('hidden');
  }
}

// 清空日志
function clearLog() {
  document.getElementById('log-entries').innerHTML = '';
}

// 添加日志条目
function addLogEntry(message, type = 'info') {
  const logContainer = document.getElementById('log-entries');
  
  // 限制日志条目数量，避免内存占用过大
  const entries = logContainer.querySelectorAll('.log-entry');
  if (entries.length >= MAX_LOG_ENTRIES) {
    // 移除最早的20%日志条目
    const removeCount = Math.ceil(MAX_LOG_ENTRIES * 0.2);
    for (let i = 0; i < removeCount; i++) {
      if (logContainer.firstChild) {
        logContainer.removeChild(logContainer.firstChild);
      }
    }
    // 添加一条提示信息
    if (logContainer.firstChild === logContainer.querySelector('.log-entry-trimmed')) {
      // 已经有提示，不重复添加
    } else {
      const trimNotice = document.createElement('div');
      trimNotice.className = 'log-entry log-entry-trimmed warning';
      trimNotice.textContent = `为提高性能，已移除 ${removeCount} 条较早的日志...`;
      logContainer.insertBefore(trimNotice, logContainer.firstChild);
    }
  }
  
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  
  // 添加时间戳
  const timeStamp = new Date().toLocaleTimeString();
  const timeSpan = document.createElement('span');
  timeSpan.className = 'log-entry-time';
  timeSpan.textContent = `[${timeStamp}]`;
  
  entry.appendChild(timeSpan);
  entry.appendChild(document.createTextNode(` ${message}`));
  
  // 添加到日志容器
  logContainer.appendChild(entry);
  
  // 自动滚动到底部
  logContainer.scrollTop = logContainer.scrollHeight;
  
  // 如果日志不可见且是重要信息，自动显示
  if (!logVisible && (type === 'error' || type === 'warning')) {
    toggleLogVisibility();
  }
  
  // 同时在控制台记录
  console.log(`[${type}] ${message}`);
}

// 检查API连接状态
function checkApiStatus() {
  chrome.storage.sync.get(['apiProvider', 'apiKey'], (result) => {
    const apiStatusElement = document.getElementById('api-status');
    
    if (result.apiProvider && result.apiKey) {
      apiStatus = true;
      apiStatusElement.textContent = '已连接';
      apiStatusElement.className = 'api-connected';
      addLogEntry(`API状态：已连接 (提供商: ${result.apiProvider})`, 'success');
    } else {
      apiStatus = false;
      apiStatusElement.textContent = '未连接';
      apiStatusElement.className = 'api-not-connected';
      addLogEntry('API状态：未连接，请先在设置中配置API', 'warning');
    }
  });
}

// 打开选项页面
function openOptions() {
  chrome.runtime.openOptionsPage();
}

// 分析书签
async function analyzeBookmarks() {
  if (!apiStatus) {
    showStatus('请先在设置中配置API连接', 'error');
    addLogEntry('API未连接，请先在设置中配置API连接', 'error');
    return;
  }
  
  // 清空之前的日志
  clearLog();
  
  // 显示加载动画和进度条
  showLoading(true);
  showProgress(true);
  showStatus('正在获取书签...');
  addLogEntry('开始书签分析过程...', 'info');
  
  // 显示取消按钮，隐藏分析按钮
  toggleAnalyzeButtons(true);
  
  try {
    // 重置状态
    categories = {};
    currentBatchIndex = 0;
    processingBatch = false;
    
    // 获取所有书签
    addLogEntry('正在获取所有书签...', 'info');
    bookmarks = await getAllBookmarks();
    totalBookmarksCount = bookmarks.length;
    
    // 添加标签层级统计
    addLogEntry('开始分析书签结构...', 'info');
    const folderStructure = {};
    
    bookmarks.forEach(bookmark => {
      if (bookmark.parentId) {
        folderStructure[bookmark.parentId] = folderStructure[bookmark.parentId] || [];
        folderStructure[bookmark.parentId].push(bookmark.id);
      }
    });
    
    // 统计书签所在的文件夹分布
    const folderDistribution = Object.entries(folderStructure)
      .map(([folderId, bookmarkIds]) => ({
        folderId,
        count: bookmarkIds.length
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
    
    addLogEntry('书签文件夹分布(TOP5):', 'info');
    folderDistribution.forEach(folder => {
      addLogEntry(`  - 文件夹ID ${folder.folderId}: 包含${folder.count}个书签`, 'info');
    });
    
    addLogEntry(`成功获取 ${totalBookmarksCount} 个书签`, 'success');
    showStatus(`已获取 ${totalBookmarksCount} 个书签，正在分批分析...`);
    
    // 获取API设置和批处理大小
    addLogEntry('正在获取API设置...', 'info');
    const settings = await getApiSettings();
    batchSize = settings.batchSize;
    
    addLogEntry(`API提供商: ${settings.provider}, 模型: ${settings.model}`, 'info');
    addLogEntry(`批处理大小: ${batchSize}`, 'info');
    
    // 开始批处理
    processingBatch = true;
    addLogEntry('开始批量处理书签...', 'info');
    await processBatches(settings);
    
  } catch (error) {
    console.error('分析书签时出错:', error);
    addLogEntry(`分析出错: ${error.message}`, 'error');
    showStatus(`分析出错: ${error.message}`, 'error');
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 取消分析
function cancelAnalyze() {
  processingBatch = false;
  addLogEntry('用户请求取消分析，正在中断处理...', 'warning');
  showStatus('正在取消分析...');
}

// 切换分析/取消按钮
function toggleAnalyzeButtons(isProcessing) {
  const analyzeButton = document.getElementById('analyze-bookmarks');
  const cancelButton = document.getElementById('cancel-analyze');
  
  if (isProcessing) {
    analyzeButton.classList.add('hidden');
    cancelButton.classList.remove('hidden');
  } else {
    analyzeButton.classList.remove('hidden');
    cancelButton.classList.add('hidden');
  }
}

// 更新进度条
function updateProgress(current, total) {
  const progressBar = document.getElementById('progress-bar');
  const percentage = Math.min(Math.round((current / total) * 100), 100);
  progressBar.style.width = `${percentage}%`;
}

// 批量处理书签
async function processBatches(settings) {
  try {
    const totalBatches = Math.ceil(bookmarks.length / batchSize);
    addLogEntry(`总共将分成 ${totalBatches} 个批次处理`, 'info');
    
    // 记录内存使用情况
    if (window.performance && window.performance.memory) {
      const memoryInfo = window.performance.memory;
      addLogEntry(`初始内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`, 'info');
    }
    
    while (currentBatchIndex < totalBatches && processingBatch) {
      const startIdx = currentBatchIndex * batchSize;
      const endIdx = Math.min(startIdx + batchSize, bookmarks.length);
      const currentBatch = bookmarks.slice(startIdx, endIdx);
      
      // 更新进度条
      updateProgress(startIdx, bookmarks.length);
      
      const batchInfo = `批次 ${currentBatchIndex + 1}/${totalBatches} (${startIdx + 1}-${endIdx}/${totalBookmarksCount})`;
      showStatus(`正在处理第 ${currentBatchIndex + 1}/${totalBatches} 批书签 (${startIdx + 1}-${endIdx}/${totalBookmarksCount})...`);
      addLogEntry(`开始处理${batchInfo}`, 'info');
      
      // 等待一小段时间让UI更新
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // 分类当前批次的书签
      addLogEntry(`正在调用API对${batchInfo}进行分类...`, 'info');
      const startTime = Date.now();
      
      // 使用try-catch单独处理每批，避免一批失败影响整体
      try {
        const batchCategories = await categorizeBookmarks(currentBatch, settings);
        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        // 记录分类结果
        const categoryCount = Object.keys(batchCategories).length;
        addLogEntry(`${batchInfo}分类完成，用时${elapsedTime}秒，分为${categoryCount}个类别`, 'success');
        
        // 打印每个类别的书签数量（仅打印前10个类别，避免日志过多）
        const categoriesToLog = Object.entries(batchCategories).slice(0, 10);
        categoriesToLog.forEach(([category, items]) => {
          addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
        });
        
        if (Object.keys(batchCategories).length > 10) {
          addLogEntry(`  - ... 以及 ${Object.keys(batchCategories).length - 10} 个其他类别`, 'info');
        }
        
        // 合并分类结果
        addLogEntry(`正在合并${batchInfo}分类结果...`, 'info');
        mergeCategoryResults(batchCategories);
        
      } catch (batchError) {
        addLogEntry(`处理${batchInfo}时出错: ${batchError.message}，跳过此批次`, 'error');
        console.error(`批次处理错误:`, batchError);
      }
      
      // 批次处理完成后，等待一段时间让UI刷新，防止浏览器卡死
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // 限制显示类别数量，避免DOM过度膨胀
      displayCategories(categories, 20);
      
      // 每处理3批，手动触发垃圾回收并清理不再需要的数据
      if (currentBatchIndex % 3 === 0) {
        addLogEntry('执行内存优化...', 'info');
        
        // 清除当前批次的临时变量
        const currentBatch = null;
        
        // 在后台任务中执行昂贵的清理操作
        setTimeout(() => {
          // 提示浏览器进行垃圾回收
          if (window.gc) {
            try {
              window.gc();
            } catch (e) {
              // 忽略，某些浏览器不支持手动垃圾回收
            }
          }
          
          // 记录内存使用情况
          if (window.performance && window.performance.memory) {
            const memoryInfo = window.performance.memory;
            console.log(`当前内存使用: ${Math.round(memoryInfo.usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(memoryInfo.jsHeapSizeLimit / (1024 * 1024))}MB`);
          }
        }, 0);
      }
      
      // 更新进度
      currentBatchIndex++;
    }
    
    // 更新到100%
    updateProgress(bookmarks.length, bookmarks.length);
    
    if (processingBatch) {
      // 全部处理完成
      const finalCategories = Object.keys(categories).length;
      showStatus(`分析完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      addLogEntry(`分析全部完成！共 ${totalBookmarksCount} 个书签被分为 ${finalCategories} 类`, 'success');
      addLogEntry(`===============================`, 'success');
      
      // 保存分析历史版本
      await saveBookmarkHistory();
      
      // 生成可视化图表
      generateVisualizations();
      
      // 释放内存
      setTimeout(() => {
        addLogEntry('正在优化内存使用...', 'info');
        // 仅保留必要数据
        bookmarks = bookmarks.map(bookmark => ({
          id: bookmark.id,
          title: bookmark.title,
          url: bookmark.url,
          parentId: bookmark.parentId
        }));
        
        // 提示浏览器进行垃圾回收
        if (window.gc) {
          try {
            window.gc();
          } catch (e) {
            // 忽略
          }
        }
      }, 1000);
      
      // 显示最终分类统计（限制数量）
      const topCategories = Object.entries(categories)
        .sort((a, b) => b[1].length - a[1].length)
        .slice(0, 20);
      
      topCategories.forEach(([category, items]) => {
        addLogEntry(`${category}: ${items.length}个书签`, 'success');
      });
      
      if (Object.keys(categories).length > 20) {
        addLogEntry(`... 以及 ${Object.keys(categories).length - 20} 个其他类别`, 'success');
      }
      
      // 完成后显示全部分类
      displayCategories(categories);
    } else {
      // 用户取消了处理
      showStatus('书签分析已中断', 'error');
      addLogEntry('书签分析被用户中断', 'warning');
    }
  } catch (error) {
    console.error('批处理书签时出错:', error);
    showStatus(`批处理出错: ${error.message}`, 'error');
    addLogEntry(`批处理出错: ${error.message}`, 'error');
  } finally {
    processingBatch = false;
    showLoading(false);
    showProgress(false);
    toggleAnalyzeButtons(false);
  }
}

// 使用Worker合并分类结果
function mergeCategoryResults(batchCategories) {
  // 检查Worker是否可用
  if (bookmarkWorker) {
    try {
      // 通过Worker合并分类
      bookmarkWorker.postMessage({
        action: 'merge-categories',
        data: {
          existingCategories: categories,
          newCategories: batchCategories
        }
      });
      return; // Worker会异步更新categories
    } catch (error) {
      console.error('Worker合并分类失败，回退到主线程:', error);
      addLogEntry('Worker处理失败，切换至主线程', 'warning');
    }
  }
  
  // 回退到主线程处理
  for (const [category, items] of Object.entries(batchCategories)) {
    if (!categories[category]) {
      categories[category] = [];
    }
    
    categories[category] = categories[category].concat(items);
  }
}

// 获取所有书签
function getAllBookmarks() {
  return new Promise((resolve) => {
    chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      const bookmarks = [];
      
      // 添加调试信息
      addLogEntry(`开始获取书签树...`, 'info');
      console.log('书签树根节点:', bookmarkTreeNodes);
      
      // 递归函数，遍历书签树
      function processNode(node) {
        // 如果是书签（有url属性）
        if (node.url) {
          // 记录原始书签数据，用于调试
          console.log('处理书签:', { id: node.id, title: node.title, url: node.url });
          
          // 添加标签信息到日志
          addLogEntry(`获取书签: ID=${node.id}, 标题="${node.title}", URL=${node.url.substring(0, 30)}...`, 'info');
          
          // 验证并处理标题
          let processedTitle = node.title || '';
          // 如果标题为空或只包含数字，尝试从URL生成更有意义的标题
          if (!processedTitle || /^\d+$/.test(processedTitle)) {
            try {
              const url = new URL(node.url);
              // 使用主机名作为标题的一部分
              processedTitle = url.hostname.replace(/^www\./, '');
              addLogEntry(`发现无效书签标题(${node.title})，已自动替换为: ${processedTitle}`, 'warning');
            } catch (e) {
              // URL解析失败，保留原标题
              processedTitle = node.title || '未命名书签';
            }
          }
          
          bookmarks.push({
            id: node.id,
            title: processedTitle,
            url: node.url,
            parentId: node.parentId,
            originalTitle: node.title // 保存原始标题以便比较
          });
        }
        
        // 如果是文件夹，记录文件夹信息
        if (!node.url && node.title) {
          addLogEntry(`发现书签文件夹: ID=${node.id}, 标题="${node.title}"`, 'info');
        }
        
        // 如果有子节点，继续处理
        if (node.children) {
          addLogEntry(`处理文件夹"${node.title || '根目录'}"的${node.children.length}个子项`, 'info');
          for (const child of node.children) {
            processNode(child);
          }
        }
      }
      
      // 从根节点开始处理
      for (const node of bookmarkTreeNodes) {
        processNode(node);
      }
      
      // 添加调试信息
      const emptyTitles = bookmarks.filter(b => !b.title).length;
      const numericTitles = bookmarks.filter(b => /^\d+$/.test(b.title)).length;
      addLogEntry(`书签获取完成: 总计${bookmarks.length}个书签, ${emptyTitles}个空标题, ${numericTitles}个纯数字标题`, 'info');
      
      // 添加更详细的分类统计
      const domainMap = {};
      bookmarks.forEach(bookmark => {
        try {
          const url = new URL(bookmark.url);
          const domain = url.hostname.replace(/^www\./, '');
          domainMap[domain] = (domainMap[domain] || 0) + 1;
        } catch (e) {
          // 忽略无效URL
        }
      });
      
      // 输出前10个最常见的域名
      const topDomains = Object.entries(domainMap)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      if (topDomains.length > 0) {
        addLogEntry(`最常见的域名:`, 'info');
        topDomains.forEach(([domain, count]) => {
          addLogEntry(`  - ${domain}: ${count}个书签`, 'info');
        });
      }
      
      resolve(bookmarks);
    });
  });
}

// 获取API设置
function getApiSettings() {
  return new Promise((resolve) => {
    chrome.storage.sync.get([
      'apiProvider', 
      'apiKey', 
      'customApiUrl', 
      'geminiModel', 
      'openaiModel', 
      'customModel', 
      'defaultCategories', 
      'batchSize'
    ], (result) => {
      const apiProvider = result.apiProvider || 'gemini';
      let model = '';
      
      // 根据提供商选择对应的模型
      switch (apiProvider) {
        case 'gemini':
          model = result.geminiModel || 'gemini-2.0-flash';
          break;
        case 'openai':
          model = result.openaiModel || 'gpt-3.5-turbo';
          break;
        case 'custom':
          model = result.customModel || '';
          break;
      }
      
      resolve({
        provider: apiProvider,
        apiKey: result.apiKey || '',
        customApiUrl: result.customApiUrl || '',
        model: model,
        defaultCategories: result.defaultCategories || '技术,教育,购物,社交媒体,新闻,娱乐,工作,其他',
        batchSize: result.batchSize || 50
      });
    });
  });
}

// 使用AI对书签进行分类
async function categorizeBookmarks(bookmarks, settings) {
  // 增强预处理：检查并修复书签数据
  addLogEntry(`开始预处理书签数据...`, 'info');
  
  // 统计有效书签数量
  const validBookmarks = bookmarks.filter(b => b.title && b.url).length;
  const totalBookmarks = bookmarks.length;
  if (validBookmarks < totalBookmarks) {
    addLogEntry(`警告: 检测到${totalBookmarks - validBookmarks}个无效书签 (无标题或URL)`, 'warning');
  }
  
  // 标签长度统计
  const titleLengths = bookmarks.map(b => b.title ? b.title.length : 0);
  const avgTitleLength = titleLengths.reduce((sum, len) => sum + len, 0) / titleLengths.length || 0;
  const maxTitleLength = Math.max(...titleLengths);
  const minTitleLength = Math.min(...(titleLengths.filter(len => len > 0) || [0]));
  
  addLogEntry(`标签标题统计: 平均长度=${avgTitleLength.toFixed(1)}字符, 最长=${maxTitleLength}字符, 最短=${minTitleLength}字符`, 'info');
  
  // 检查常见的特殊标签
  const specialPatterns = {
    '纯数字标题': /^\d+$/,
    '包含特殊字符': /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/,
    '非中文标题': /^[^\u4e00-\u9fa5]+$/,
    '过长标题(>30字符)': title => title.length > 30
  };
  
  const specialStats = {};
  Object.keys(specialPatterns).forEach(key => {
    specialStats[key] = 0;
  });
  
  bookmarks.forEach(bookmark => {
    if (bookmark.title) {
      Object.entries(specialPatterns).forEach(([key, pattern]) => {
        if (typeof pattern === 'function') {
          if (pattern(bookmark.title)) specialStats[key]++;
        } else if (pattern.test(bookmark.title)) {
          specialStats[key]++;
        }
      });
    }
  });
  
  addLogEntry(`标签特征统计:`, 'info');
  Object.entries(specialStats).forEach(([key, count]) => {
    const percentage = ((count / totalBookmarks) * 100).toFixed(1);
    addLogEntry(`  - ${key}: ${count}个 (${percentage}%)`, 'info');
  });
  
  // 预处理：创建更友好的数据集
  const bookmarkData = bookmarks.map(b => {
    // 尝试从URL提取域名作为附加信息
    let domain = '';
    try {
      if (b.url) {
        const urlObj = new URL(b.url);
        domain = urlObj.hostname.replace(/^www\./, '');
      }
    } catch (e) {
      // URL解析失败，忽略
    }
    
    return {
      title: b.title || domain || '未命名书签',
      url: b.url || '',
      domain: domain
    };
  });
  
  // 简单自动分类：尝试预先识别一些常见类别
  const preCategorized = {};
  const domainPatterns = {
    // AI工具和服务
    '通用AI工具': [/gemini\.google\.com/, /openai\.com/, /chat\.openai\.com/, /perplexity\.ai/, /claude\.ai/, /poe\.com/],
    'AI开发平台': [/aistudio\.google\.com/, /platform\.openai\.com/, /colab\.research\.google/, /huggingface\.co/],
    'AI笔记工具': [/notebooklm\.google\.com/, /notion\.ai/, /obsidian\.md/],
    
    // 设计工具和平台
    'UI设计工具': [/figma\.com/, /sketch\.com/, /adobe\.com/, /canva\.com/, /framer\.com/],
    '原型设计': [/gamma\.app/, /miro\.com/, /whimsical\.com/, /mockplus\.com/, /axure\.com/],
    '开发设计工具': [/lovable\.dev/, /v0\.dev/, /bolt\.new/, /replit\.com/, /codesandbox\.io/],
    
    // 教程和学习资源
    'UI设计教程': [/uisdc\.com/, /uxdesign\.cc/, /dribbble\.com/, /behance\.net/, /designbetter\.co/],
    '技术教程': [/csdn\.net/, /juejin\.cn/, /segmentfault\.com/, /dev\.to/, /medium\.com/],
    '在线课程': [/coursera\.org/, /udemy\.com/, /edx\.org/, /khan.*academy/, /freecodecamp\.org/],
    
    // 开发工具
    '代码托管': [/github\.com/, /gitlab\.com/, /gitee\.com/, /bitbucket\.org/],
    '技术问答': [/stackoverflow\.com/, /stackexchange\.com/, /zhihu\.com/],
    '文档工具': [/gitbook\.com/, /docsify\.js\.org/, /vuepress\.vuejs\.org/],
    
    // 实用工具
    '翻译工具': [/translate\.google\.com/, /deepl\.com/, /fanyi\.baidu\.com/, /youdao\.com/],
    '图片工具': [/tinypng\.com/, /remove\.bg/, /unsplash\.com/, /pexels\.com/],
    '在线办公': [/docs\.google\.com/, /office\.com/, /notion\.so/, /airtable\.com/],
    
    // 传统分类（保留但细化）
    '视频娱乐': [/youtube\.com/, /bilibili\.com/, /netflix\.com/, /youku\.com/, /iqiyi\.com/],
    '社交媒体': [/twitter\.com/, /facebook\.com/, /instagram\.com/, /weibo\.com/, /linkedin\.com/, /reddit\.com/],
    '电商购物': [/taobao\.com/, /jd\.com/, /amazon\.com/, /tmall\.com/, /pinduoduo\.com/],
    '邮箱服务': [/mail\./, /gmail\.com/, /outlook\.com/, /qq\.com.*mail/],
    '新闻资讯': [/news\./, /sina\.com/, /qq\.com/, /163\.com/, /bbc\./, /cnn\./]
  };
  
  // 基于书签标题的关键词匹配（增强识别能力）
  const titleKeywords = {
    'AI工具教程': ['AI教程', 'ChatGPT教程', 'Gemini使用', '人工智能教程', 'AI学习', 'machine learning'],
    'UI设计素材': ['设计素材', 'UI素材', '图标', 'icon', '配色', 'color', '字体', 'font'],
    'UI设计案例': ['设计案例', 'UI案例', '界面设计', '交互设计', 'UX案例', '设计灵感'],
    'Figma教程': ['Figma', 'figma教程', '组件库', 'design system'],
    '游戏UI设计': ['游戏UI', '游戏界面', 'game ui', 'game design'],
    '前端开发': ['前端', 'frontend', 'Vue', 'React', 'Angular', 'JavaScript'],
    '后端开发': ['后端', 'backend', 'API', 'Node.js', 'Python', 'Java'],
    '移动开发': ['移动开发', 'iOS', 'Android', 'Flutter', 'React Native']
  };
  
  // 尝试做一些预分类，帮助AI更好理解
  bookmarkData.forEach(bookmark => {
    let categorized = false;
    
    // 首先尝试域名匹配
    for (const [category, patterns] of Object.entries(domainPatterns)) {
      if (patterns.some(pattern => pattern.test(bookmark.domain || bookmark.url))) {
        if (!preCategorized[category]) {
          preCategorized[category] = [];
        }
        preCategorized[category].push(bookmark);
        categorized = true;
        break; // 一个书签只归入一个预分类
      }
    }
    
    // 如果域名没有匹配到，尝试标题关键词匹配
    if (!categorized && bookmark.title) {
      const title = bookmark.title.toLowerCase();
      for (const [category, keywords] of Object.entries(titleKeywords)) {
        if (keywords.some(keyword => title.includes(keyword.toLowerCase()))) {
          if (!preCategorized[category]) {
            preCategorized[category] = [];
          }
          preCategorized[category].push(bookmark);
          break;
        }
      }
    }
  });
  
  // 输出预分类结果
  addLogEntry(`预分类结果:`, 'info');
  Object.entries(preCategorized).forEach(([category, items]) => {
    addLogEntry(`  - ${category}: ${items.length}个书签`, 'info');
  });
  
  // 统计未被预分类的书签数量
  const preCategorizedCount = Object.values(preCategorized).reduce((sum, items) => sum + items.length, 0);
  const uncategorizedCount = bookmarkData.length - preCategorizedCount;
  addLogEntry(`预分类统计: 已分类${preCategorizedCount}个 (${((preCategorizedCount/bookmarkData.length)*100).toFixed(1)}%), 未分类${uncategorizedCount}个`, 'info');
  
  // 添加预分类信息到提示词中，帮助AI更好地理解
  const preCategorizedInfo = Object.entries(preCategorized)
    .map(([category, items]) => `- ${category}: ${items.length}个书签，例如: ${items.slice(0, 3).map(b => b.title).join(', ')}...`)
    .join('\n');
  
  // 构建提示词
  const prompt = `你是一个专业的书签分类助手。请对以下书签进行详细分类，创建有意义且细致的分类体系。

分类指导原则：
1. 分类数量：鼓励创建10-25个细分类别，根据书签内容的丰富程度灵活调整
2. 分类细度：优先创建细致、专业的分类，而不是宽泛的大类
3. 分类名称：使用准确、专业的中文词汇，体现具体用途或领域
4. 禁止使用：数字(0,1,2...)、字母(A,B,C...)或特殊符号作为分类名
5. 输出格式：严格JSON格式，不添加其他说明文字

建议的细分类别示例（根据实际内容调整）：
- AI工具类：通用AI工具、AI开发平台、AI笔记工具、AI工具教程
- 设计类：UI设计工具、原型设计、UI设计教程、UI设计素材、设计案例、Figma教程
- 开发类：代码托管、技术教程、前端开发、后端开发、技术问答
- 实用工具：翻译工具、图片工具、在线办公
- 学习资源：在线课程、技术文档、设计学习

${preCategorizedInfo ? `参考预分类（可进一步细分或调整）：\n${preCategorizedInfo}\n` : ''}

请根据书签的具体内容和用途，创建尽可能准确和细致的分类：

输出格式：
{
  "通用AI工具": [
    {"title": "Gemini", "url": "https://gemini.google.com/app"},
    {"title": "Perplexity", "url": "https://www.perplexity.ai/"}
  ],
  "AI开发平台": [
    {"title": "Google AI Studio", "url": "https://aistudio.google.com/"}
  ],
  "UI设计教程": [
    {"title": "Figma组件库教程", "url": "https://www.uisdc.com/..."}
  ]
}

需要分类的书签：
${JSON.stringify(bookmarkData, null, 2)}`;

  // 根据API提供商选择合适的处理方法
  let categoryResult;
  try {
    addLogEntry(`开始调用AI进行书签分类...`, 'info');
    
    switch (settings.provider) {
      case 'gemini':
        categoryResult = await callGeminiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'openai':
        categoryResult = await callOpenAiApi(prompt, settings.apiKey, settings.model);
        break;
      case 'custom':
        categoryResult = await callCustomApi(settings.apiKey, settings.customApiUrl, settings.model, prompt);
        break;
      default:
        throw new Error('不支持的API提供商');
    }
    
    addLogEntry(`AI分类完成，获得${Object.keys(categoryResult).length}个分类`, 'success');
    
    // 分析分类质量
    const categoryNames = Object.keys(categoryResult);
    const numericCategories = categoryNames.filter(name => /^\d+$/.test(name)).length;
    const shortCategories = categoryNames.filter(name => name.length < 2).length;
    const longCategories = categoryNames.filter(name => name.length > 10).length;
    
    addLogEntry(`分类质量分析:`, 'info');
    addLogEntry(`  - 纯数字分类: ${numericCategories}个`, numericCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过短分类(小于2字符): ${shortCategories}个`, shortCategories > 0 ? 'warning' : 'info');
    addLogEntry(`  - 过长分类(大于10字符): ${longCategories}个`, longCategories > 0 ? 'info' : 'info');
    
    // 如果API返回空结果或没有分类，尝试使用预分类结果
    if (!categoryResult || Object.keys(categoryResult).length === 0) {
      addLogEntry('API返回的分类结果为空，尝试使用预分类结果', 'warning');
      
      if (Object.keys(preCategorized).length > 0) {
        categoryResult = preCategorized;
        addLogEntry(`使用预分类结果: ${Object.keys(preCategorized).length}个分类`, 'info');
      } else {
        // 创建一个基本分类
        categoryResult = { "未分类": bookmarkData };
        addLogEntry(`无法获取有效分类，所有书签归为"未分类"`, 'error');
      }
    }
    
    // 验证并优化分类结果
    return validateAndOptimizeCategories(categoryResult, bookmarks.length);
  } catch (error) {
    console.error('分类处理失败:', error);
    addLogEntry(`分类处理失败: ${error.message}，尝试使用备用方案`, 'error');
    
    // 出错时使用预分类作为备用方案
    if (Object.keys(preCategorized).length > 0) {
      // 将未预分类的书签放入"其他"分类
      const uncategorized = bookmarkData.filter(bookmark => {
        return !Object.values(preCategorized).some(items => 
          items.some(item => item.url === bookmark.url)
        );
      });
      
      if (uncategorized.length > 0) {
        preCategorized["其他"] = uncategorized;
      }
      
      addLogEntry(`使用预分类作为备用方案: ${Object.keys(preCategorized).length}个分类`, 'info');
      return preCategorized;
    }
    
    // 如果没有预分类，使用基本分类
    const basicCategories = {
      "常用网站": bookmarkData.slice(0, Math.min(20, bookmarkData.length)),
      "其他书签": bookmarkData.slice(Math.min(20, bookmarkData.length))
    };
    
    addLogEntry(`无法进行分类，使用基本分类方案`, 'warning');
    return basicCategories;
  }
}

// 验证并优化分类结果
function validateAndOptimizeCategories(categories, totalBookmarks) {
  // 提高分类数量限制，鼓励细分
  const MAX_CATEGORIES = 30; // 从20提高到30
  let categoriesCount = Object.keys(categories).length;
  
  // 只有在分类数量严重超标时才进行合并
  if (categoriesCount > MAX_CATEGORIES) {
    addLogEntry(`分类数量(${categoriesCount})超过最大限制(${MAX_CATEGORIES})，正在适度优化...`, 'warning');
    
    // 获取所有分类及其书签数量
    const categoriesWithCount = Object.entries(categories)
      .map(([name, items]) => ({ name, count: items.length }))
      .sort((a, b) => b.count - a.count);
    
    // 保留前25个分类，只合并极小的分类（少于等于1个书签的）
    const mainCategories = categoriesWithCount.slice(0, MAX_CATEGORIES - 5);
    const smallCategories = categoriesWithCount.slice(MAX_CATEGORIES - 5);
    
    // 只合并真正的小分类（1个书签的分类）
    const verySmallCategories = smallCategories.filter(cat => cat.count <= 1);
    const keepCategories = smallCategories.filter(cat => cat.count > 1);
    
    // 创建新的分类结果
    const optimizedCategories = {};
    
    // 添加主要分类
    mainCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 保留有意义的小分类（超过1个书签）
    keepCategories.forEach(cat => {
      optimizedCategories[cat.name] = categories[cat.name];
    });
    
    // 只合并极小的分类
    if (verySmallCategories.length > 0) {
      optimizedCategories["其他"] = optimizedCategories["其他"] || [];
      verySmallCategories.forEach(cat => {
        optimizedCategories["其他"] = optimizedCategories["其他"].concat(categories[cat.name]);
      });
      addLogEntry(`已将${verySmallCategories.length}个单书签分类合并到"其他"`, 'info');
    }
    
    return optimizedCategories;
  }
  
  // 验证分类名称，修复纯数字或无意义的分类名
  const optimizedCategories = {};
  const numericPattern = /^[\d]+$/;  // 匹配纯数字
  
  Object.entries(categories).forEach(([categoryName, items]) => {
    let newName = categoryName;
    
    // 检查是否为纯数字或太短的分类名
    if (numericPattern.test(categoryName) || categoryName.length < 2) {
      // 尝试根据内容推断更好的名称
      newName = inferCategoryName(items) || "其他";
      addLogEntry(`已修正无效的分类名"${categoryName}"为"${newName}"`, 'warning');
    }
    
    // 添加到优化后的分类
    if (!optimizedCategories[newName]) {
      optimizedCategories[newName] = [];
    }
    optimizedCategories[newName] = optimizedCategories[newName].concat(items);
  });
  
  addLogEntry(`分类验证完成，保留${Object.keys(optimizedCategories).length}个分类`, 'success');
  
  return optimizedCategories;
}

// 尝试根据书签内容推断分类名称
function inferCategoryName(bookmarks) {
  // 常见网站类型映射
  const domainCategories = {
    'github.com': '程序开发',
    'youtube.com': '视频娱乐',
    'bilibili.com': '视频娱乐',
    'zhihu.com': '问答社区',
    'taobao.com': '网上购物',
    'jd.com': '网上购物',
    'tmall.com': '网上购物',
    'weibo.com': '社交媒体',
    'twitter.com': '社交媒体',
    'facebook.com': '社交媒体',
    'instagram.com': '社交媒体',
    'linkedin.com': '职业社交',
    'stackoverflow.com': '技术问答',
    'mail.': '电子邮箱',
    'gmail': '电子邮箱',
    'outlook': '电子邮箱',
    'docs.google.com': '在线办公',
    'notion.so': '在线办公',
    'edu.': '教育学习',
    'csdn.net': '技术博客',
    'juejin.cn': '技术博客',
    'medium.com': '博客平台'
  };
  
  // 提取所有书签的域名
  const domains = bookmarks.map(bm => {
    try {
      if (!bm.url) return '';
      const urlObj = new URL(bm.url);
      return urlObj.hostname;
    } catch {
      return '';
    }
  }).filter(Boolean);
  
  // 尝试找出最常见的域名类型
  const categoryMatches = {};
  
  domains.forEach(domain => {
    for (const [pattern, category] of Object.entries(domainCategories)) {
      if (domain.includes(pattern)) {
        categoryMatches[category] = (categoryMatches[category] || 0) + 1;
      }
    }
  });
  
  // 找出匹配最多的分类
  let bestCategory = null;
  let maxMatches = 0;
  
  for (const [category, matches] of Object.entries(categoryMatches)) {
    if (matches > maxMatches) {
      maxMatches = matches;
      bestCategory = category;
    }
  }
  
  // 如果有超过20%的书签匹配同一个分类，使用该分类
  if (bestCategory && maxMatches >= domains.length * 0.2) {
    return bestCategory;
  }
  
  // 没有找到合适的分类
  return null;
}

// 共享的JSON解析和修复函数
function parseJsonWithRecovery(jsonStr) {
  // 首先尝试直接解析
  try {
    const result = JSON.parse(jsonStr);
    return result;
  } catch (firstError) {
    addLogEntry(`初次JSON解析失败: ${firstError.message}`, 'warning');
    
    // 尝试修复常见的JSON错误
    let fixedJson = jsonStr;
    
    // 修复1: 移除可能的前导/尾随文本
    const cleanMatch = fixedJson.match(/{[\s\S]*}/);
    if (cleanMatch) {
      fixedJson = cleanMatch[0];
    }
    
    // 修复2: 处理不完整的JSON（添加缺失的大括号或方括号）
    const openBraces = (fixedJson.match(/{/g) || []).length;
    const closeBraces = (fixedJson.match(/}/g) || []).length;
    const openBrackets = (fixedJson.match(/\[/g) || []).length;
    const closeBrackets = (fixedJson.match(/]/g) || []).length;
    
    // 添加缺失的闭合括号
    for (let i = 0; i < openBraces - closeBraces; i++) {
      fixedJson += '}';
    }
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      fixedJson += ']';
    }
    
    // 修复3: 处理尾部逗号
    fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1');
    
    // 修复4: 处理缺失的引号
    fixedJson = fixedJson.replace(/(\w+):/g, '"$1":');
    
    addLogEntry(`尝试修复后的JSON: ${fixedJson.substring(0, 100)}...`, 'info');
    
    try {
      return JSON.parse(fixedJson);
    } catch (secondError) {
      addLogEntry(`JSON修复后仍然解析失败: ${secondError.message}`, 'error');
      
      // 作为最后的手段，尝试提取键值对并构建基本结构
      try {
        const fallbackResult = {};
        const keyValueMatches = fixedJson.match(/"([^"]+)":\s*\[([^\]]*)\]/g);
        
        if (keyValueMatches && keyValueMatches.length > 0) {
          addLogEntry(`尝试从键值对构建JSON结构...`, 'warning');
          
          keyValueMatches.forEach(match => {
            const kvMatch = match.match(/"([^"]+)":\s*\[([^\]]*)\]/);
            if (kvMatch) {
              const category = kvMatch[1];
              const content = kvMatch[2];
              
              // 尝试解析书签对象
              const bookmarks = [];
              const bookmarkMatches = content.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/g);
              
              if (bookmarkMatches) {
                bookmarkMatches.forEach(bmMatch => {
                  const bmParts = bmMatch.match(/{"title":\s*"([^"]+)",\s*"url":\s*"([^"]+)"}/);
                  if (bmParts) {
                    bookmarks.push({
                      title: bmParts[1],
                      url: bmParts[2]
                    });
                  }
                });
              }
              
              if (bookmarks.length > 0) {
                fallbackResult[category] = bookmarks;
              }
            }
          });
          
          if (Object.keys(fallbackResult).length > 0) {
            addLogEntry(`成功从键值对构建了${Object.keys(fallbackResult).length}个分类`, 'success');
            return fallbackResult;
          }
        }
      } catch (fallbackError) {
        addLogEntry(`备用解析方案也失败了: ${fallbackError.message}`, 'error');
      }
      
      // 如果所有尝试都失败了，抛出原始错误
      throw new Error(`JSON解析失败，已尝试多种修复方案: ${firstError.message}`);
    }
  }
}

// 通用JSON提取函数
function extractJsonFromText(responseText) {
  addLogEntry(`正在从响应中提取JSON数据...`, 'info');
  
  // 多种JSON提取策略
  let jsonText = '';
  
  // 策略1: 寻找完整的JSON代码块
  const codeBlockMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                         responseText.match(/```\s*([\s\S]*?)\s*```/);
  
  if (codeBlockMatch) {
    jsonText = codeBlockMatch[1].trim();
    addLogEntry(`从代码块中提取JSON，长度: ${jsonText.length}字符`, 'success');
  } else {
    // 策略2: 寻找第一个完整的JSON对象
    const jsonObjectMatch = responseText.match(/{[\s\S]*}/);
    if (jsonObjectMatch) {
      jsonText = jsonObjectMatch[0];
      addLogEntry(`从文本中提取JSON对象，长度: ${jsonText.length}字符`, 'success');
    } else {
      // 策略3: 使用整个响应
      jsonText = responseText.trim();
      addLogEntry(`未找到JSON格式标记，使用整个响应作为JSON`, 'warning');
    }
  }
  
  return jsonText;
}

// 调用Gemini API
async function callGeminiApi(prompt, apiKey, model) {
  try {
    // 构建URL，注意版本号
    const apiVersion = model.startsWith('gemini-1.5') ? 'v1' : 'v1beta';
    const url = `https://generativelanguage.googleapis.com/${apiVersion}/models/${model}:generateContent?key=${apiKey}`;
    
    console.log(`正在调用Gemini API，模型: ${model}`);
    addLogEntry(`正在调用Gemini API，模型: ${model}`, 'info');
    
    // 记录发送的数据，用于调试
    const requestData = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.2,
        maxOutputTokens: 2048
      }
    };
    
    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);
    
    addLogEntry(`发送请求到: ${apiVersion} 版本API...`, 'info');
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('Gemini API错误响应:', errorData);
      addLogEntry(`Gemini API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    addLogEntry(`Gemini API请求成功，正在处理响应...`, 'info');
    const data = await response.json();
    
    // 检查响应格式
    if (!data.candidates || data.candidates.length === 0) {
      console.error('Gemini API返回无效数据:', data);
      addLogEntry(`Gemini API返回无效数据，没有candidates`, 'error');
      throw new Error('API返回数据无效，没有candidates');
    }
    
    // 提取响应文本
    const responseText = data.candidates[0].content.parts[0].text;
    addLogEntry(`成功获取API响应，内容长度: ${responseText.length}字符`, 'success');
    
    // 保存完整响应以便调试
    console.log('API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('Gemini API调用出错:', error);
    addLogEntry(`Gemini API调用失败: ${error.message}`, 'error');
    throw new Error(`Gemini API调用失败: ${error.message}`);
  }
}

// 调用OpenAI API
async function callOpenAiApi(prompt, apiKey, model) {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'system',
            content: '你是一个书签分类助手，请将用户提供的书签分类，并以JSON格式返回。'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3
      })
    });
    
    if (!response.ok) {
      throw new Error(`API错误: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // 提取响应文本
    const responseText = data.choices[0].message.content;
    addLogEntry(`成功获取OpenAI API响应，内容长度: ${responseText.length}字符`, 'success');
    console.log('OpenAI API完整响应:', responseText);
    
    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(responseText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用改进的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      addLogEntry(`OpenAI JSON解析成功，包含${categoryNames.length}个分类`, 'success');
      
      return result;
    } catch (jsonError) {
      console.error('OpenAI JSON解析失败:', jsonError);
      addLogEntry(`OpenAI JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('OpenAI API调用出错:', error);
    throw new Error(`OpenAI API调用失败: ${error.message}`);
  }
}

// 调用自定义API分析书签
async function callCustomApi(apiKey, customApiUrl, model, prompt) {
  try {
    console.log('调用自定义API，URL:', customApiUrl);
    addLogEntry(`正在调用自定义API，模型: ${model}`, 'info');
    
    // 准备请求内容 - 提供多种可能的消息格式，增加兼容性
    const requestData = {
      model: model,
      prompt: prompt,
      message: prompt,
      // 兼容更多API格式
      messages: [
        { role: "user", content: prompt }
      ],
      content: prompt,
      input: prompt
    };

    // 记录提示词的一部分（避免过长）
    const promptPreview = prompt.substring(0, 200) + "...";
    addLogEntry(`API提示词预览: ${promptPreview}`, 'info');
    console.log('完整提示词:', prompt);

    addLogEntry(`发送请求到自定义API...`, 'info');
    const response = await fetch(customApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify(requestData)
    });

    const responseData = await response.json();
    if (!response.ok) {
      console.error('自定义API错误响应:', responseData);
      addLogEntry(`自定义API错误: ${response.status} ${response.statusText}`, 'error');
      throw new Error(`API响应错误: ${response.status} - ${JSON.stringify(responseData)}`);
    }

    addLogEntry(`自定义API请求成功，正在处理响应...`, 'info');
    console.log('API完整响应:', responseData);

    // 处理不同格式的API响应，提取文本内容
    let resultText = '';
    
    // 1. 直接返回字符串
    if (typeof responseData === 'string') {
      resultText = responseData;
    }
    // 2. 有标准字段的情况
    else if (responseData.text || responseData.content || responseData.message || responseData.response) {
      resultText = responseData.text || responseData.content || responseData.message || responseData.response;
    }
    // 3. OpenAI格式
    else if (responseData.choices && responseData.choices.length > 0) {
      resultText = responseData.choices[0].text || responseData.choices[0].message?.content;
    }
    // 4. 有result字段的情况
    else if (responseData.result) {
      if (typeof responseData.result === 'string') {
        resultText = responseData.result;
      } else {
        // 如果result是对象，可能直接就是分类结果
        console.log('检测到result字段为对象，直接返回:', responseData.result);
        addLogEntry(`检测到result字段为对象，直接返回`, 'info');
        return responseData.result;
      }
    }
    // 5. 整个响应就是结果
    else {
      console.log('未找到标准结果字段，尝试使用整个响应');
      addLogEntry(`未找到标准结果字段，尝试使用整个响应`, 'warning');
      resultText = JSON.stringify(responseData);
    }

    if (!resultText) {
      throw new Error('无法从API响应中提取文本内容');
    }

    addLogEntry(`成功获取API响应，内容长度: ${resultText.length}字符`, 'success');
    console.log('提取的响应文本:', resultText);

    // 从响应中提取JSON，使用共享函数
    const jsonText = extractJsonFromText(resultText);
    console.log('提取的JSON数据:', jsonText);
    addLogEntry(`准备解析的JSON文本: ${jsonText.substring(0, 100)}...`, 'info');

    try {
      // 使用共享的解析函数
      const result = parseJsonWithRecovery(jsonText);
      
      // 验证解析结果的有效性
      if (!result || typeof result !== 'object') {
        throw new Error('解析结果不是有效的对象');
      }
      
      const categoryNames = Object.keys(result);
      if (categoryNames.length === 0) {
        throw new Error('解析结果为空对象');
      }
      
      // 检查分类是否全为数字
      const numericCategories = categoryNames.filter(cat => /^\d+$/.test(cat)).length;
      const totalCategories = categoryNames.length;
      
      addLogEntry(`JSON解析成功，包含${totalCategories}个分类，其中${numericCategories}个为纯数字分类`, 'success');
      
      if (numericCategories > 0) {
        addLogEntry(`警告: 检测到${numericCategories}个纯数字分类名，这可能表示AI未能理解书签内容`, 'warning');
        console.log('纯数字分类名:', categoryNames.filter(cat => /^\d+$/.test(cat)));
      }
      
      // 检查分类内容是否有效
      let validCategories = 0;
      for (const [categoryName, items] of Object.entries(result)) {
        if (Array.isArray(items) && items.length > 0) {
          validCategories++;
          const sampleBookmark = items[0];
          if (validCategories === 1) { // 只记录第一个分类的详细信息
            addLogEntry(`分类内容格式检查: "${categoryName}" - title="${sampleBookmark.title}", url="${sampleBookmark.url}"`, 'info');
          }
        }
      }
      
      addLogEntry(`有效分类数量: ${validCategories}/${totalCategories}`, validCategories === totalCategories ? 'success' : 'warning');
      
      return result;
    } catch (jsonError) {
      console.error('JSON解析失败:', jsonError);
      addLogEntry(`JSON解析失败: ${jsonError.message}`, 'error');
      addLogEntry(`原始JSON文本（前500字符）: ${jsonText.substring(0, 500)}...`, 'error');
      throw new Error(`无法解析AI返回的JSON: ${jsonError.message}`);
    }
  } catch (error) {
    console.error('自定义API调用出错:', error);
    addLogEntry(`自定义API调用失败: ${error.message}`, 'error');
    throw new Error(`自定义API调用失败: ${error.message}`);
  }
}

// 显示分类结果
function displayCategories(categories, maxCategories = Infinity) {
  const resultsContainer = document.getElementById('results');
  resultsContainer.innerHTML = '';
  
  // 记录详细分类结果到日志
  addLogEntry(`开始显示分类结果...`, 'info');
  addLogEntry(`总共有 ${Object.keys(categories).length} 个分类`, 'info');
  
  // 优化：如果类别太多，按大小排序并限制显示数量
  const allCategories = Object.entries(categories)
    .sort((a, b) => b[1].length - a[1].length);
  
  const totalCategories = allCategories.length;
  
  // 输出详细分类信息到日志
  addLogEntry(`分类详情:`, 'info');
  allCategories.forEach(([category, items], index) => {
    addLogEntry(`  ${index+1}. ${category}: ${items.length}个书签`, 'info');
    
    // 只在日志中显示前3个书签示例
    if (items.length > 0) {
      const examples = items.slice(0, 3);
      examples.forEach((item, i) => {
        addLogEntry(`    ${i+1}) "${item.title}" (${item.url ? item.url.substring(0, 30) + '...' : '无URL'})`, 'info');
      });
      
      if (items.length > 3) {
        addLogEntry(`    ... 以及${items.length - 3}个其他书签`, 'info');
      }
    }
  });
  
  // 如果类别超过限制，显示分页控制
  if (totalCategories > maxCategories && maxCategories !== Infinity) {
    const paginationInfo = document.createElement('div');
    paginationInfo.className = 'pagination-info';
    paginationInfo.textContent = `显示${Math.min(maxCategories, totalCategories)}个类别中的前${maxCategories}个（按书签数量排序）`;
    
    const showAllButton = document.createElement('button');
    showAllButton.className = 'btn-small';
    showAllButton.textContent = '显示全部';
    showAllButton.onclick = () => displayCategories(categories);
    
    paginationInfo.appendChild(document.createTextNode(' '));
    paginationInfo.appendChild(showAllButton);
    resultsContainer.appendChild(paginationInfo);
    
    addLogEntry(`由于类别过多，UI中仅显示前${maxCategories}个类别`, 'info');
  }

  // 在分析完成后添加优化按钮
  if (maxCategories === Infinity) {
    const optimizeInfo = document.createElement('div');
    optimizeInfo.className = 'pagination-info';
    
    const optimizeForBrowserButton = document.createElement('button');
    optimizeForBrowserButton.className = 'btn-small';
    optimizeForBrowserButton.textContent = '优化为浏览器标签页结构';
    optimizeForBrowserButton.onclick = () => optimizeForBrowserTabs(categories);
    
    optimizeInfo.appendChild(optimizeForBrowserButton);
    resultsContainer.appendChild(optimizeInfo);
  }
  
  // 仅显示限制数量的类别
  const displayedCategories = allCategories.slice(0, maxCategories);
  
  // 性能优化：使用文档片段而不是直接操作DOM
  const fragment = document.createDocumentFragment();
  
  for (const [category, items] of displayedCategories) {
    const categoryElement = document.createElement('div');
    categoryElement.className = 'category';
    
    const categoryName = document.createElement('div');
    categoryName.className = 'category-name';
    categoryName.textContent = `${category} (${items.length})`;
    categoryElement.appendChild(categoryName);
    
    // 只显示前8个书签，如果超过8个，显示"更多..."
    const displayCount = Math.min(items.length, 8);
    
    // 使用内部文档片段进一步优化
    const itemsFragment = document.createDocumentFragment();
    
    for (let i = 0; i < displayCount; i++) {
      const item = items[i];
      const bookmarkItem = document.createElement('div');
      bookmarkItem.className = 'bookmark-item';
      
      const link = document.createElement('a');
      link.href = item.url;
      link.textContent = item.title || item.url;
      link.title = item.url;
      link.target = '_blank';
      
      bookmarkItem.appendChild(link);
      itemsFragment.appendChild(bookmarkItem);
    }
    
    // 如果有更多书签，显示"更多..."并添加展开功能
    if (items.length > 8) {
      const moreItem = document.createElement('div');
      moreItem.className = 'bookmark-item more-item';
      moreItem.textContent = `...还有 ${items.length - 8} 个书签`;
      
      // 添加点击展开功能
      moreItem.onclick = function() {
        // 已经展开的情况下折叠
        if (this.expanded) {
          // 移除额外书签
          const extras = categoryElement.querySelectorAll('.extra-bookmark');
          extras.forEach(item => item.remove());
          
          // 恢复文本和状态
          this.textContent = `...还有 ${items.length - 8} 个书签`;
          this.expanded = false;
          return;
        }
        
        // 未展开的情况下展开显示所有书签
        const extraItemsFragment = document.createDocumentFragment();
        
        for (let i = 8; i < items.length; i++) {
          const item = items[i];
          const bookmarkItem = document.createElement('div');
          bookmarkItem.className = 'bookmark-item extra-bookmark';
          
          const link = document.createElement('a');
          link.href = item.url;
          link.textContent = item.title || item.url;
          link.title = item.url;
          link.target = '_blank';
          
          bookmarkItem.appendChild(link);
          extraItemsFragment.appendChild(bookmarkItem);
        }
        
        // 插入额外书签
        categoryElement.insertBefore(extraItemsFragment, this);
        
        // 更新"更多"项文本和状态
        this.textContent = "折叠";
        this.expanded = true;
      };
      
      itemsFragment.appendChild(moreItem);
    }
    
    categoryElement.appendChild(itemsFragment);
    fragment.appendChild(categoryElement);
  }
  
  resultsContainer.appendChild(fragment);
  
  // 如果还有更多类别未显示，添加"查看更多类别"按钮
  if (allCategories.length > maxCategories && maxCategories !== Infinity) {
    const viewMoreButton = document.createElement('button');
    viewMoreButton.className = 'btn';
    viewMoreButton.textContent = `查看剩余 ${allCategories.length - maxCategories} 个类别`;
    viewMoreButton.onclick = () => displayCategories(categories);
    
    resultsContainer.appendChild(viewMoreButton);
  }
  
  addLogEntry(`分类结果显示完成`, 'success');
}

// 优化为浏览器标签页结构
async function optimizeForBrowserTabs(categories) {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    return;
  }
  
  // 确认操作
  if (!confirm('此操作将重新组织分类，创建更符合浏览器标签页结构的分组。是否继续？')) {
    return;
  }
  
  addLogEntry('正在优化分类结构为浏览器标签页...', 'info');
  showLoading(true);
  
  try {
    // 默认标签页数量，通常浏览器有7-8个标签页
    const TARGET_TAB_COUNT = 7;
    
    // 根据内容相似性将现有分类整合成约7个大分类
    const primaryCategories = [
      {name: "工作与生产力", patterns: ["工作", "办公", "文档", "生产力", "效率", "管理", "会议", "邮箱", "协作"]},
      {name: "技术与开发", patterns: ["技术", "编程", "开发", "代码", "程序", "设计", "博客", "github", "stack"]},
      {name: "学习与教育", patterns: ["学习", "教育", "课程", "培训", "知识", "教程", "学校", "研究", "科学"]},
      {name: "娱乐与休闲", patterns: ["娱乐", "视频", "音乐", "游戏", "电影", "电视", "动漫", "直播", "体育"]},
      {name: "社交与媒体", patterns: ["社交", "媒体", "新闻", "资讯", "论坛", "社区", "微博", "朋友", "交友"]},
      {name: "购物与消费", patterns: ["购物", "电商", "消费", "商城", "网购", "优惠", "团购", "店铺", "商品"]},
      {name: "生活与服务", patterns: ["生活", "服务", "餐饮", "美食", "旅游", "出行", "健康", "医疗", "银行"]}
    ];
    
    // 创建新的分类结构
    const optimizedCategories = {};
    primaryCategories.forEach(pc => {
      optimizedCategories[pc.name] = [];
    });
    optimizedCategories["其他"] = []; // 默认兜底分类
    
    // 将所有书签分配到新的分类中
    for (const [category, bookmarks] of Object.entries(categories)) {
      // 为当前分类找到最匹配的主分类
      let bestMatch = null;
      let highestScore = 0;
      
      // 计算当前分类与每个主分类的匹配度
      for (const pc of primaryCategories) {
        let score = 0;
        // 分类名称匹配
        for (const pattern of pc.patterns) {
          if (category.toLowerCase().includes(pattern)) {
            score += 3;  // 分类名匹配权重高
            break;
          }
        }
        
        // 书签内容匹配
        for (const bookmark of bookmarks) {
          const title = bookmark.title?.toLowerCase() || '';
          const url = bookmark.url?.toLowerCase() || '';
          
          for (const pattern of pc.patterns) {
            if (title.includes(pattern) || url.includes(pattern)) {
              score += 1;  // 每个书签匹配加1分
            }
          }
        }
        
        // 更新最佳匹配
        if (score > highestScore) {
          highestScore = score;
          bestMatch = pc.name;
        }
      }
      
      // 分配书签
      if (bestMatch && highestScore > 0) {
        optimizedCategories[bestMatch] = optimizedCategories[bestMatch].concat(bookmarks);
      } else {
        optimizedCategories["其他"] = optimizedCategories["其他"].concat(bookmarks);
      }
    }
    
    // 移除空分类
    Object.keys(optimizedCategories).forEach(key => {
      if (optimizedCategories[key].length === 0) {
        delete optimizedCategories[key];
      }
    });
    
    // 保存优化后的分类
    categories = optimizedCategories;
    
    // 更新历史版本
    await saveBookmarkHistory('浏览器标签页优化');
    
    // 显示优化后的分类
    displayCategories(categories);
    
    // 更新状态
    showStatus(`已优化为${Object.keys(categories).length}个主要分类，更符合浏览器标签页结构`, 'success');
    addLogEntry(`优化完成，已将书签重组为${Object.keys(categories).length}个主要分类`, 'success');
  } catch (error) {
    console.error('优化分类结构失败:', error);
    showStatus(`优化失败: ${error.message}`, 'error');
    addLogEntry(`优化分类结构失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 整理书签
async function organizeBookmarks() {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    addLogEntry('无法整理书签：请先进行分析', 'error');
    return;
  }
  
  addLogEntry('开始整理书签到文件夹...', 'info');
  showLoading(true);
  showProgress(true);
  showStatus('正在整理书签...');
  
  try {
    // 获取"其他书签"文件夹ID
    const otherBookmarksId = '2';
    addLogEntry(`目标文件夹："其他书签" (ID: ${otherBookmarksId})`, 'info');
    
    let organizedCount = 0;
    const totalCount = Object.values(categories).reduce((sum, items) => sum + items.length, 0);
    addLogEntry(`总共需要整理 ${totalCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'info');
    
    // 对每个分类创建文件夹
    for (const category of Object.keys(categories)) {
      // 创建分类文件夹
      addLogEntry(`正在创建/检查分类文件夹: "${category}"`, 'info');
      const categoryFolder = await createBookmarkFolder(category, otherBookmarksId);
      addLogEntry(`分类文件夹 "${category}" 已就绪 (ID: ${categoryFolder.id})`, 'success');
      
      // 移动书签到对应文件夹
      const itemsInCategory = categories[category].length;
      addLogEntry(`开始移动 ${itemsInCategory} 个书签到 "${category}" 文件夹`, 'info');
      
      for (const bookmark of categories[category]) {
        // 查找书签原始ID
        const originalBookmark = bookmarks.find(b => b.url === bookmark.url && b.title === bookmark.title);
        
        if (originalBookmark) {
          await moveBookmark(originalBookmark.id, categoryFolder.id);
          organizedCount++;
          
          // 更新进度条
          updateProgress(organizedCount, totalCount);
          
          // 每整理10个书签更新一次状态
          if (organizedCount % 10 === 0) {
            showStatus(`正在整理书签...${organizedCount}/${totalCount}`);
            addLogEntry(`已整理 ${organizedCount}/${totalCount} 个书签`, 'info');
          }
        } else {
          addLogEntry(`警告：无法找到书签 "${bookmark.title}" 的原始ID`, 'warning');
        }
      }
      
      addLogEntry(`完成 "${category}" 类别的整理`, 'success');
    }
    
    showStatus(`书签整理完成！共整理 ${organizedCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'success');
    addLogEntry(`===============================`, 'success');
    addLogEntry(`整理完成！共整理 ${organizedCount}/${totalCount} 个书签到 ${Object.keys(categories).length} 个分类文件夹`, 'success');
    addLogEntry(`===============================`, 'success');
    
    // 保存历史版本
    await saveBookmarkHistory('整理后');
    
  } catch (error) {
    console.error('整理书签时出错:', error);
    showStatus(`整理出错: ${error.message}`, 'error');
    addLogEntry(`整理出错: ${error.message}`, 'error');
  } finally {
    showLoading(false);
    showProgress(false);
  }
}

// 创建书签文件夹
function createBookmarkFolder(title, parentId) {
  return new Promise((resolve, reject) => {
    // 先检查是否已存在同名文件夹
    chrome.bookmarks.getChildren(parentId, (children) => {
      const existingFolder = children.find(child => 
        child.title === title && !child.url
      );
      
      if (existingFolder) {
        resolve(existingFolder);
      } else {
        // 创建新文件夹
        chrome.bookmarks.create({
          parentId: parentId,
          title: title
        }, (newFolder) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(newFolder);
          }
        });
      }
    });
  });
}

// 移动书签
function moveBookmark(bookmarkId, newParentId) {
  return new Promise((resolve, reject) => {
    chrome.bookmarks.move(bookmarkId, { parentId: newParentId }, (result) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else {
        resolve(result);
      }
    });
  });
}

// 导出分类结果为CSV文件
function exportBookmarks() {
  if (Object.keys(categories).length === 0) {
    showStatus('请先分析书签', 'error');
    addLogEntry('无法导出：请先进行分析', 'error');
    return;
  }
  
  addLogEntry('开始导出分类结果为CSV文件...', 'info');
  
  try {
    // 创建CSV内容
    let csvContent = '类别,标题,URL\n';
    let totalRows = 0;
    
    for (const [category, items] of Object.entries(categories)) {
      addLogEntry(`正在处理"${category}"类别 (${items.length}个书签)...`, 'info');
      
      for (const item of items) {
        // 处理CSV特殊字符
        const safeTitle = item.title ? `"${item.title.replace(/"/g, '""')}"` : '';
        const safeUrl = `"${item.url.replace(/"/g, '""')}"`;
        
        csvContent += `"${category}",${safeTitle},${safeUrl}\n`;
        totalRows++;
      }
    }
    
    addLogEntry(`CSV内容准备完成，总共 ${totalRows} 行数据`, 'success');
    
    // 创建下载链接
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 设置下载属性
    const fileName = `书签分类_${new Date().toISOString().slice(0, 10)}.csv`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    // 添加到DOM, 触发下载, 然后移除
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`CSV文件"${fileName}"下载已开始`, 'success');
    showStatus('CSV文件导出成功', 'success');
  } catch (error) {
    console.error('导出CSV时出错:', error);
    addLogEntry(`导出CSV失败: ${error.message}`, 'error');
    showStatus('导出失败', 'error');
  }
}

// 显示状态信息
function showStatus(message, type = '') {
  const statusElement = document.getElementById('status');
  statusElement.textContent = message;
  statusElement.style.display = 'block';
  
  // 清除所有类
  statusElement.className = 'status';
  
  // 添加类型类
  if (type) {
    statusElement.classList.add(type);
  }
}

// 显示/隐藏加载指示器
function showLoading(show) {
  document.getElementById('loading').style.display = show ? 'block' : 'none';
}

// 显示/隐藏进度条
function showProgress(show) {
  const progressElement = document.getElementById('progress');
  
  if (show) {
    progressElement.style.display = 'block';
    // 重置进度条
    document.getElementById('progress-bar').style.width = '0%';
  } else {
    progressElement.style.display = 'none';
  }
}

// 保存书签分类历史版本
async function saveBookmarkHistory(suffix = '') {
  try {
    const timestamp = Date.now();
    const historyId = `history_${timestamp}`;
    
    // 创建版本描述
    const categoryCount = Object.keys(categories).length;
    const description = `${totalBookmarksCount}个书签分为${categoryCount}个类别${suffix ? ` (${suffix})` : ''}`;
    
    // 构建历史记录对象
    const historyEntry = {
      id: historyId,
      timestamp,
      description,
      categories: JSON.parse(JSON.stringify(categories)),
      bookmarkCount: totalBookmarksCount,
      dateString: new Date(timestamp).toLocaleString()
    };
    
    // 获取现有历史记录
    const result = await chrome.storage.local.get('bookmarkHistory');
    const history = result.bookmarkHistory || [];
    
    // 添加新版本并保存
    history.unshift(historyEntry);
    
    // 限制历史记录数量（保留最近10条）
    const limitedHistory = history.slice(0, 10);
    
    await chrome.storage.local.set({ bookmarkHistory: limitedHistory });
    addLogEntry(`历史版本已保存: ${description}`, 'success');
  } catch (error) {
    console.error('保存历史版本失败:', error);
    addLogEntry(`保存历史版本失败: ${error.message}`, 'error');
  }
}

// 打开历史版本页面
function openHistoryPage() {
  chrome.tabs.create({ url: 'history.html' });
}

// 生成可视化图表
function generateVisualizations() {
  setTimeout(() => {
    try {
      // 显示可视化容器
      document.querySelector('.visualization-container').classList.remove('hidden');
      
      let successCount = 0;
      let totalAttempts = 3;
      
      // 检查Chart.js是否可用
      if (typeof Chart === 'undefined') {
        addLogEntry('Chart.js库未加载，跳过饼图生成', 'warning');
      } else {
        try {
          // 生成饼图
          generateCategoryPieChart();
          successCount++;
          addLogEntry('饼图生成成功', 'success');
        } catch (chartError) {
          addLogEntry(`饼图生成失败: ${chartError.message}`, 'error');
        }
      }
      
      // 检查D3是否可用
      if (typeof d3 === 'undefined') {
        addLogEntry('D3.js库未加载，跳过树形图生成', 'warning');
      } else {
        try {
          // 生成树形图
          generateCategoryTreeView();
          successCount++;
          addLogEntry('树形图生成成功', 'success');
        } catch (d3Error) {
          addLogEntry(`树形图生成失败: ${d3Error.message}`, 'error');
        }
      }
      
      // 生成标签云（不依赖外部库）
      try {
        generateTagCloud();
        successCount++;
        addLogEntry('标签云生成成功', 'success');
      } catch (tagCloudError) {
        addLogEntry(`标签云生成失败: ${tagCloudError.message}`, 'error');
      }
      
      if (successCount > 0) {
        addLogEntry(`可视化图表生成完成，成功生成 ${successCount}/${totalAttempts} 个图表`, 'success');
      } else {
        addLogEntry('所有可视化图表生成均失败', 'error');
        // 显示一个简单的文本统计作为备用
        showSimpleStatistics();
      }
      
    } catch (error) {
      console.error('生成可视化图表失败:', error);
      addLogEntry(`生成可视化图表失败: ${error.message}`, 'error');
      
      // 显示简单统计作为备用
      showSimpleStatistics();
    }
  }, 500);
}

// 显示简单的文本统计（备用方案）
function showSimpleStatistics() {
  try {
    const container = document.querySelector('.visualization-content');
    if (!container) return;
    
    // 创建简单统计面板
    const statsDiv = document.createElement('div');
    statsDiv.innerHTML = `
      <h3>书签分类统计</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
        ${Object.entries(categories)
          .sort((a, b) => b[1].length - a[1].length)
          .slice(0, 10)
          .map(([category, items]) => `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #4285f4;">
              <div style="font-weight: bold; color: #1a73e8; margin-bottom: 5px;">${category}</div>
              <div style="font-size: 24px; font-weight: bold; color: #34a853;">${items.length}</div>
              <div style="font-size: 12px; color: #5f6368;">个书签</div>
            </div>
          `).join('')}
      </div>
    `;
    
    // 替换可视化内容
    container.innerHTML = '';
    container.appendChild(statsDiv);
    
    addLogEntry('显示简单文本统计作为备用方案', 'info');
  } catch (error) {
    addLogEntry(`备用统计显示失败: ${error.message}`, 'error');
  }
}

// 切换可视化选项卡
function switchVisualizationTab(event) {
  // 移除所有标签页和内容的active类
  document.querySelectorAll('.viz-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelectorAll('.viz-panel').forEach(panel => {
    panel.classList.remove('active');
  });
  
  // 设置当前标签页为active
  event.target.classList.add('active');
  
  // 显示对应的内容面板
  const tabName = event.target.dataset.tab;
  document.getElementById(`${tabName}-container`).classList.add('active');
}

// ======== 书签检测功能 ========

// 检测重复书签
async function detectDuplicateBookmarks() {
  addLogEntry('开始检测重复书签...', 'info');
  showLoading(true);
  showStatus('正在检测重复书签...');
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    addLogEntry(`获取到 ${allBookmarks.length} 个书签，开始分析重复项`, 'info');
    
    // 按URL分组检测重复
    const urlGroups = {};
    const titleGroups = {};
    
    allBookmarks.forEach(bookmark => {
      // 按URL分组
      const normalizedUrl = normalizeUrl(bookmark.url);
      if (!urlGroups[normalizedUrl]) {
        urlGroups[normalizedUrl] = [];
      }
      urlGroups[normalizedUrl].push(bookmark);
      
      // 按标题分组（用于检测可能的重复）
      const normalizedTitle = bookmark.title.toLowerCase().trim();
      if (normalizedTitle && normalizedTitle.length > 3) {
        if (!titleGroups[normalizedTitle]) {
          titleGroups[normalizedTitle] = [];
        }
        titleGroups[normalizedTitle].push(bookmark);
      }
    });
    
    // 找出重复项
    const duplicateGroups = [];
    
    // URL重复
    Object.entries(urlGroups).forEach(([url, bookmarks]) => {
      if (bookmarks.length > 1) {
        duplicateGroups.push({
          type: 'url',
          key: url,
          bookmarks: bookmarks,
          reason: 'URL相同'
        });
      }
    });
    
    // 标题重复（排除已经在URL重复中的）
    Object.entries(titleGroups).forEach(([title, bookmarks]) => {
      if (bookmarks.length > 1) {
        // 检查是否已经在URL重复组中
        const urls = bookmarks.map(b => normalizeUrl(b.url));
        const isAlreadyDetected = duplicateGroups.some(group => 
          group.type === 'url' && urls.some(url => url === group.key)
        );
        
        if (!isAlreadyDetected) {
          duplicateGroups.push({
            type: 'title',
            key: title,
            bookmarks: bookmarks,
            reason: '标题相同'
          });
        }
      }
    });
    
    addLogEntry(`检测完成，发现 ${duplicateGroups.length} 组重复书签`, 'success');
    
    // 显示检测结果
    displayDuplicateResults(duplicateGroups);
    showStatus(`检测完成，发现 ${duplicateGroups.length} 组重复书签`, 'success');
    
  } catch (error) {
    console.error('检测重复书签失败:', error);
    addLogEntry(`检测重复书签失败: ${error.message}`, 'error');
    showStatus(`检测失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 标准化URL（去除查询参数、锚点等）
function normalizeUrl(url) {
  try {
    const urlObj = new URL(url);
    // 移除www前缀
    let hostname = urlObj.hostname.replace(/^www\./, '');
    // 移除尾随斜杠
    let pathname = urlObj.pathname.replace(/\/$/, '') || '/';
    
    return `${urlObj.protocol}//${hostname}${pathname}`;
  } catch (e) {
    return url.toLowerCase().trim();
  }
}

// 显示重复书签检测结果
function displayDuplicateResults(duplicateGroups) {
  const container = document.getElementById('detection-container');
  const duplicateResults = document.getElementById('duplicate-results');
  const duplicateList = document.getElementById('duplicate-list');
  
  container.classList.remove('hidden');
  
  if (duplicateGroups.length === 0) {
    duplicateResults.classList.add('hidden');
    return;
  }
  
  duplicateResults.classList.remove('hidden');
  duplicateList.innerHTML = '';
  
  let totalDuplicates = 0;
  
  duplicateGroups.forEach((group, groupIndex) => {
    const groupElement = document.createElement('div');
    groupElement.className = 'duplicate-group';
    
    const groupHeader = document.createElement('div');
    groupHeader.className = 'duplicate-group-header';
    groupHeader.textContent = `${group.reason} - ${group.bookmarks.length} 个重复项`;
    groupElement.appendChild(groupHeader);
    
    group.bookmarks.forEach((bookmark, index) => {
      const item = document.createElement('div');
      item.className = 'detection-item';
      
      // 跳过第一个（保留原始），其余标记为重复
      const isDuplicate = index > 0;
      if (isDuplicate) {
        totalDuplicates++;
      }
      
      item.innerHTML = `
        <input type="checkbox" class="detection-checkbox" 
               data-type="duplicate" 
               data-id="${bookmark.id}" 
               ${isDuplicate ? 'checked' : 'disabled'}>
        <div class="detection-info">
          <div class="detection-title">${bookmark.title || '无标题'}</div>
          <div class="detection-url">${bookmark.url}</div>
          <div class="detection-meta">
            ${isDuplicate ? '📄 重复项' : '✅ 原始项'} | 
            ID: ${bookmark.id} | 
            父文件夹: ${bookmark.parentId}
          </div>
        </div>
      `;
      
      groupElement.appendChild(item);
    });
    
    duplicateList.appendChild(groupElement);
  });
  
  // 显示操作按钮
  document.getElementById('remove-duplicates').classList.remove('hidden');
  document.getElementById('select-all-duplicates').classList.remove('hidden');
  document.getElementById('deselect-all-duplicates').classList.remove('hidden');
  
  addLogEntry(`显示重复检测结果：${duplicateGroups.length} 组，共 ${totalDuplicates} 个重复项`, 'info');
}

// 检测失效书签
async function detectInvalidBookmarks() {
  addLogEntry('开始检测失效书签...', 'info');
  showLoading(true);
  showStatus('正在检测失效书签...');
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    addLogEntry(`获取到 ${allBookmarks.length} 个书签，开始检测失效链接`, 'info');
    
    const invalidBookmarks = [];
    const batchSize = 10; // 并发检测数量
    let checkedCount = 0;
    
    // 分批检测书签有效性
    for (let i = 0; i < allBookmarks.length; i += batchSize) {
      const batch = allBookmarks.slice(i, i + batchSize);
      
      // 并发检测当前批次
      const batchPromises = batch.map(async (bookmark) => {
        try {
          const isValid = await checkBookmarkValidity(bookmark.url);
          checkedCount++;
          
          // 更新进度
          if (checkedCount % 20 === 0) {
            showStatus(`正在检测失效书签... ${checkedCount}/${allBookmarks.length}`);
            addLogEntry(`已检测 ${checkedCount}/${allBookmarks.length} 个书签`, 'info');
          }
          
          if (!isValid) {
            invalidBookmarks.push(bookmark);
          }
        } catch (error) {
          addLogEntry(`检测书签 "${bookmark.title}" 时出错: ${error.message}`, 'warning');
          // 检测出错的也视为可能失效
          invalidBookmarks.push(bookmark);
        }
      });
      
      await Promise.all(batchPromises);
      
      // 批次间稍作延迟，避免过于频繁的请求
      if (i + batchSize < allBookmarks.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    addLogEntry(`检测完成，发现 ${invalidBookmarks.length} 个失效书签`, 'success');
    
    // 显示检测结果
    displayInvalidResults(invalidBookmarks);
    showStatus(`检测完成，发现 ${invalidBookmarks.length} 个失效书签`, 'success');
    
  } catch (error) {
    console.error('检测失效书签失败:', error);
    addLogEntry(`检测失效书签失败: ${error.message}`, 'error');
    showStatus(`检测失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 检查单个书签的有效性
async function checkBookmarkValidity(url) {
  return new Promise((resolve) => {
    // 设置超时时间
    const timeout = 10000; // 10秒超时
    
    const timeoutId = setTimeout(() => {
      resolve(false); // 超时视为失效
    }, timeout);
    
    // 使用fetch检测URL可访问性
    fetch(url, {
      method: 'HEAD', // 只获取头部信息，减少数据传输
      mode: 'no-cors', // 避免CORS问题
      cache: 'no-cache'
    })
    .then(response => {
      clearTimeout(timeoutId);
      // 对于no-cors模式，response.ok可能不准确，所以检查type
      resolve(response.type !== 'error');
    })
    .catch(error => {
      clearTimeout(timeoutId);
      // 网络错误或其他问题
      resolve(false);
    });
  });
}

// 显示失效书签检测结果
function displayInvalidResults(invalidBookmarks) {
  const container = document.getElementById('detection-container');
  const invalidResults = document.getElementById('invalid-results');
  const invalidList = document.getElementById('invalid-list');
  
  container.classList.remove('hidden');
  
  if (invalidBookmarks.length === 0) {
    invalidResults.classList.add('hidden');
    return;
  }
  
  invalidResults.classList.remove('hidden');
  invalidList.innerHTML = '';
  
  invalidBookmarks.forEach(bookmark => {
    const item = document.createElement('div');
    item.className = 'detection-item';
    
    item.innerHTML = `
      <input type="checkbox" class="detection-checkbox" 
             data-type="invalid" 
             data-id="${bookmark.id}" 
             checked>
      <div class="detection-info">
        <div class="detection-title">${bookmark.title || '无标题'}</div>
        <div class="detection-url">${bookmark.url}</div>
        <div class="detection-meta">
          ❌ 失效链接 | 
          ID: ${bookmark.id} | 
          父文件夹: ${bookmark.parentId}
        </div>
      </div>
    `;
    
    invalidList.appendChild(item);
  });
  
  // 显示操作按钮
  document.getElementById('remove-invalid').classList.remove('hidden');
  document.getElementById('select-all-invalid').classList.remove('hidden');
  document.getElementById('deselect-all-invalid').classList.remove('hidden');
  
  addLogEntry(`显示失效检测结果：${invalidBookmarks.length} 个失效书签`, 'info');
}

// 清理书签（检测空文件夹）
async function cleanupBookmarks() {
  addLogEntry('开始清理书签，检测空文件夹...', 'info');
  showLoading(true);
  showStatus('正在检测空文件夹...');
  
  try {
    // 获取书签树
    const bookmarkTree = await new Promise((resolve) => {
      chrome.bookmarks.getTree(resolve);
    });
    
    const emptyFolders = [];
    
    // 递归检查空文件夹
    function checkEmptyFolders(node) {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const hasBookmarks = node.children.some(child => child.url);
        const hasNonEmptySubfolders = node.children.some(child => 
          !child.url && child.children && child.children.length > 0
        );
        
        if (!hasBookmarks && !hasNonEmptySubfolders && node.children.length === 0) {
          // 空文件夹
          emptyFolders.push(node);
        }
        
        // 递归检查子文件夹
        node.children.forEach(checkEmptyFolders);
      }
    }
    
    bookmarkTree.forEach(checkEmptyFolders);
    
    addLogEntry(`检测完成，发现 ${emptyFolders.length} 个空文件夹`, 'success');
    
    // 显示检测结果
    displayEmptyFolderResults(emptyFolders);
    showStatus(`检测完成，发现 ${emptyFolders.length} 个空文件夹`, 'success');
    
  } catch (error) {
    console.error('清理书签失败:', error);
    addLogEntry(`清理书签失败: ${error.message}`, 'error');
    showStatus(`清理失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 显示空文件夹检测结果
function displayEmptyFolderResults(emptyFolders) {
  const container = document.getElementById('detection-container');
  const emptyFolderResults = document.getElementById('empty-folders-results');
  const emptyFolderList = document.getElementById('empty-folders-list');
  
  container.classList.remove('hidden');
  
  if (emptyFolders.length === 0) {
    emptyFolderResults.classList.add('hidden');
    return;
  }
  
  emptyFolderResults.classList.remove('hidden');
  emptyFolderList.innerHTML = '';
  
  emptyFolders.forEach(folder => {
    const item = document.createElement('div');
    item.className = 'detection-item';
    
    item.innerHTML = `
      <input type="checkbox" class="detection-checkbox" 
             data-type="empty-folder" 
             data-id="${folder.id}" 
             checked>
      <div class="detection-info">
        <div class="detection-title">📁 ${folder.title || '无标题文件夹'}</div>
        <div class="detection-url">空文件夹</div>
        <div class="detection-meta">
          🗂️ 空文件夹 | 
          ID: ${folder.id} | 
          父文件夹: ${folder.parentId}
        </div>
      </div>
    `;
    
    emptyFolderList.appendChild(item);
  });
  
  // 显示操作按钮
  document.getElementById('remove-empty-folders').classList.remove('hidden');
  document.getElementById('select-all-empty-folders').classList.remove('hidden');
  document.getElementById('deselect-all-empty-folders').classList.remove('hidden');
  
  addLogEntry(`显示空文件夹检测结果：${emptyFolders.length} 个空文件夹`, 'info');
}

// ======== 检测结果操作功能 ========

// 移除重复书签
async function removeDuplicateBookmarks() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="duplicate"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的重复书签', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个重复书签吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个重复书签...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const bookmarkId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.remove(bookmarkId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除书签 ${bookmarkId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个重复书签`, 'success');
    showStatus(`成功删除 ${deletedCount} 个重复书签`, 'success');
    
  } catch (error) {
    addLogEntry(`删除重复书签失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 移除失效书签
async function removeInvalidBookmarks() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="invalid"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的失效书签', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个失效书签吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个失效书签...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const bookmarkId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.remove(bookmarkId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除书签 ${bookmarkId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个失效书签`, 'success');
    showStatus(`成功删除 ${deletedCount} 个失效书签`, 'success');
    
  } catch (error) {
    addLogEntry(`删除失效书签失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 移除空文件夹
async function removeEmptyFolders() {
  const selectedItems = document.querySelectorAll('.detection-checkbox[data-type="empty-folder"]:checked');
  
  if (selectedItems.length === 0) {
    showStatus('请选择要删除的空文件夹', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除 ${selectedItems.length} 个空文件夹吗？此操作不可撤销。`)) {
    return;
  }
  
  addLogEntry(`开始删除 ${selectedItems.length} 个空文件夹...`, 'info');
  showLoading(true);
  
  try {
    let deletedCount = 0;
    
    for (const item of selectedItems) {
      const folderId = item.dataset.id;
      
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.removeTree(folderId, () => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve();
            }
          });
        });
        
        deletedCount++;
        item.closest('.detection-item').remove();
        
      } catch (error) {
        addLogEntry(`删除文件夹 ${folderId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`成功删除 ${deletedCount} 个空文件夹`, 'success');
    showStatus(`成功删除 ${deletedCount} 个空文件夹`, 'success');
    
  } catch (error) {
    addLogEntry(`删除空文件夹失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 选择/取消选择检测项目
function selectAllDetectionItems(type, select) {
  const checkboxes = document.querySelectorAll(`.detection-checkbox[data-type="${type}"]`);
  checkboxes.forEach(checkbox => {
    if (!checkbox.disabled) {
      checkbox.checked = select;
    }
  });
  
  addLogEntry(`${select ? '选择' : '取消选择'}了 ${checkboxes.length} 个${type}项目`, 'info');
}

// ======== 书签管理器功能 ========

// 打开书签管理器
async function openBookmarkManager() {
  addLogEntry('打开书签管理器...', 'info');
  showLoading(true);
  
  try {
    // 验证浏览器API可用性
    if (!chrome || !chrome.bookmarks) {
      throw new Error('Chrome书签API不可用，请检查扩展权限');
    }
    
    addLogEntry('Chrome书签API验证通过', 'success');
    
    // 加载书签树
    await loadBookmarkTree();
    
    // 验证数据完整性
    if (!bookmarkTreeData || bookmarkTreeData.length === 0) {
      throw new Error('未获取到书签数据或书签数据为空');
    }
    
    addLogEntry(`书签数据验证通过，包含 ${bookmarkTreeData.length} 个根节点`, 'success');
    
    // 显示书签管理器容器
    const container = document.getElementById('bookmark-manager-container');
    if (!container) {
      throw new Error('找不到书签管理器容器元素');
    }
    
    container.classList.remove('hidden');
    addLogEntry('书签管理器容器显示成功', 'success');
    
    // 渲染书签树
    renderBookmarkTree();
    
    // 验证渲染结果
    const treeContainer = document.getElementById('bookmark-tree');
    const renderedNodes = treeContainer.querySelectorAll('.tree-node');
    addLogEntry(`书签树渲染完成，共渲染 ${renderedNodes.length} 个节点`, 'success');
    
    // 验证统计面板
    const statsPanel = document.querySelector('.bookmark-stats-panel');
    if (statsPanel) {
      addLogEntry('统计面板创建成功', 'success');
    } else {
      addLogEntry('警告: 统计面板未正确创建', 'warning');
    }
    
    addLogEntry('书签管理器加载完成', 'success');
    showStatus('书签管理器已打开', 'success');
    
  } catch (error) {
    console.error('打开书签管理器失败:', error);
    addLogEntry(`打开书签管理器失败: ${error.message}`, 'error');
    showStatus(`打开失败: ${error.message}`, 'error');
    
    // 显示详细的错误诊断信息
    addLogEntry('开始错误诊断...', 'info');
    
    // 检查API权限
    if (!chrome) {
      addLogEntry('错误: Chrome扩展API不可用', 'error');
    } else if (!chrome.bookmarks) {
      addLogEntry('错误: Chrome书签API不可用，请检查manifest.json中的权限配置', 'error');
    } else {
      addLogEntry('Chrome API可用，错误可能来自其他原因', 'info');
    }
    
    // 检查DOM元素
    const container = document.getElementById('bookmark-manager-container');
    if (!container) {
      addLogEntry('错误: 找不到书签管理器容器元素 #bookmark-manager-container', 'error');
    }
    
    const treeContainer = document.getElementById('bookmark-tree');
    if (!treeContainer) {
      addLogEntry('错误: 找不到书签树容器元素 #bookmark-tree', 'error');
    }
    
  } finally {
    showLoading(false);
  }
}

// 加载书签树数据
async function loadBookmarkTree() {
  return new Promise((resolve, reject) => {
    chrome.bookmarks.getTree((bookmarkTreeNodes) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
        return;
      }
      
      bookmarkTreeData = bookmarkTreeNodes;
      addLogEntry(`书签树加载完成，根节点数: ${bookmarkTreeNodes.length}`, 'info');
      
      // 添加详细的书签统计信息
      const stats = analyzeBookmarkTree(bookmarkTreeNodes);
      addLogEntry(`书签统计: 总计${stats.totalBookmarks}个书签, ${stats.totalFolders}个文件夹, ${stats.maxDepth}层深度`, 'success');
      addLogEntry(`文件夹分布: 书签栏${stats.bookmarkBar}个, 其他书签${stats.otherBookmarks}个, 移动设备书签${stats.mobileBookmarks}个`, 'info');
      
      resolve(bookmarkTreeNodes);
    });
  });
}

// 分析书签树统计信息
function analyzeBookmarkTree(nodes) {
  const stats = {
    totalBookmarks: 0,
    totalFolders: 0,
    maxDepth: 0,
    bookmarkBar: 0,
    otherBookmarks: 0,
    mobileBookmarks: 0
  };
  
  function analyzeNode(node, depth = 0) {
    stats.maxDepth = Math.max(stats.maxDepth, depth);
    
    if (node.url) {
      // 这是一个书签
      stats.totalBookmarks++;
      
      // 根据父节点ID统计分布
      if (node.parentId === '1') {
        stats.bookmarkBar++;
      } else if (node.parentId === '2') {
        stats.otherBookmarks++;
      } else if (node.parentId === '3') {
        stats.mobileBookmarks++;
      }
    } else if (node.children) {
      // 这是一个文件夹
      if (node.id !== '0') { // 排除根节点
        stats.totalFolders++;
      }
      
      // 递归分析子节点
      node.children.forEach(child => analyzeNode(child, depth + 1));
    }
  }
  
  nodes.forEach(node => analyzeNode(node));
  return stats;
}

// 渲染书签树
function renderBookmarkTree() {
  const container = document.getElementById('bookmark-tree');
  container.innerHTML = '';
  
  // 清空选择状态
  selectedBookmarks.clear();
  
  // 添加统计信息面板
  const statsPanel = document.createElement('div');
  statsPanel.className = 'bookmark-stats-panel';
  statsPanel.innerHTML = `
    <div class="stats-header">📊 书签统计</div>
    <div class="stats-content" id="bookmark-stats-content">正在计算...</div>
  `;
  container.appendChild(statsPanel);
  
  // 渲染每个根节点
  bookmarkTreeData.forEach(rootNode => {
    const treeElement = createTreeNode(rootNode, 0);
    container.appendChild(treeElement);
  });
  
  // 更新统计信息
  updateBookmarkStats();
  
  addLogEntry('书签树渲染完成', 'info');
  
  // 自动展开第一级文件夹（书签栏、其他书签等）
  setTimeout(() => {
    expandFirstLevelFolders();
  }, 100);
}

// 更新书签统计信息
function updateBookmarkStats() {
  const stats = analyzeBookmarkTree(bookmarkTreeData);
  const statsContent = document.getElementById('bookmark-stats-content');
  
  if (statsContent) {
    statsContent.innerHTML = `
      <div class="stat-item">📚 总书签: <strong>${stats.totalBookmarks}</strong></div>
      <div class="stat-item">📁 总文件夹: <strong>${stats.totalFolders}</strong></div>
      <div class="stat-item">📊 最大深度: <strong>${stats.maxDepth}</strong>层</div>
      <div class="stat-breakdown">
        <div>书签栏: ${stats.bookmarkBar} | 其他书签: ${stats.otherBookmarks} | 移动设备: ${stats.mobileBookmarks}</div>
      </div>
    `;
  }
}

// 展开第一级文件夹
function expandFirstLevelFolders() {
  // 找到所有第一级文件夹（书签栏、其他书签、移动设备书签等）
  const firstLevelFolders = document.querySelectorAll('.tree-node[style*="margin-left: 0px"] .tree-expand-btn, .tree-node[style*="margin-left: 20px"] .tree-expand-btn');
  
  let expandedCount = 0;
  firstLevelFolders.forEach(button => {
    const nodeElement = button.closest('.tree-node');
    const childrenContainer = nodeElement.querySelector('.tree-children');
    
    if (childrenContainer && childrenContainer.classList.contains('hidden')) {
      childrenContainer.classList.remove('hidden');
      button.textContent = '▼';
      expandedCount++;
    }
  });
  
  addLogEntry(`自动展开了${expandedCount}个主要文件夹`, 'info');
}

// 创建树节点
function createTreeNode(node, level) {
  const nodeElement = document.createElement('div');
  nodeElement.className = 'tree-node';
  nodeElement.style.marginLeft = `${level * 20}px`;
  nodeElement.dataset.nodeId = node.id;
  nodeElement.dataset.nodeType = node.url ? 'bookmark' : 'folder';
  
  // 添加拖拽功能
  nodeElement.draggable = true;
  nodeElement.addEventListener('dragstart', handleDragStart);
  nodeElement.addEventListener('dragover', handleDragOver);
  nodeElement.addEventListener('drop', handleDrop);
  nodeElement.addEventListener('dragend', handleDragEnd);
  
  // 添加调试信息
  if (level === 0) {
    addLogEntry(`创建根节点: ${node.title} (ID: ${node.id})`, 'info');
  }
  
  // 节点内容容器
  const nodeContent = document.createElement('div');
  nodeContent.className = 'tree-node-content';
  
  // 展开/折叠按钮（仅文件夹）
  if (!node.url && node.children) {
    const expandButton = document.createElement('button');
    expandButton.className = 'tree-expand-btn';
    expandButton.textContent = '▶';
    expandButton.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleNodeExpansion(nodeElement, expandButton);
    });
    nodeContent.appendChild(expandButton);
    
    // 添加文件夹书签数量显示
    const bookmarkCount = countBookmarksInFolder(node);
    if (bookmarkCount > 0) {
      const countSpan = document.createElement('span');
      countSpan.className = 'folder-count';
      countSpan.textContent = ` (${bookmarkCount})`;
      countSpan.title = `包含 ${bookmarkCount} 个书签`;
    }
  } else {
    // 书签项的占位符
    const spacer = document.createElement('span');
    spacer.className = 'tree-spacer';
    spacer.textContent = '  ';
    nodeContent.appendChild(spacer);
  }
  
  // 复选框
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'tree-checkbox';
  checkbox.addEventListener('change', (e) => {
    e.stopPropagation();
    toggleBookmarkSelection(node.id, checkbox.checked);
  });
  nodeContent.appendChild(checkbox);
  
  // 拖拽手柄
  const dragHandle = document.createElement('span');
  dragHandle.className = 'drag-handle';
  dragHandle.textContent = '⋮⋮';
  dragHandle.title = '拖拽以重新排序';
  nodeContent.appendChild(dragHandle);
  
  // 图标和标题
  const icon = document.createElement('span');
  icon.className = 'tree-icon';
  icon.textContent = node.url ? '🔖' : '📁';
  nodeContent.appendChild(icon);
  
  // 标题容器（支持内联编辑）
  const titleContainer = document.createElement('div');
  titleContainer.className = 'tree-title-container';
  
  const title = document.createElement('span');
  title.className = 'tree-title';
  title.textContent = node.title || '无标题';
  title.dataset.originalTitle = node.title || '';
  
  // 添加双击编辑功能
  title.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    startInlineEdit(title, node);
  });
  
  // 添加URL工具提示（仅书签）
  if (node.url) {
    title.title = node.url;
  }
  
  titleContainer.appendChild(title);
  
  // 内联编辑输入框（初始隐藏）
  const editInput = document.createElement('input');
  editInput.type = 'text';
  editInput.className = 'tree-title-edit hidden';
  editInput.value = node.title || '';
  editInput.addEventListener('blur', () => finishInlineEdit(editInput, title, node));
  editInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      finishInlineEdit(editInput, title, node);
    } else if (e.key === 'Escape') {
      cancelInlineEdit(editInput, title);
    }
  });
  
  titleContainer.appendChild(editInput);
  nodeContent.appendChild(titleContainer);
  
  // 操作按钮
  const actions = document.createElement('div');
  actions.className = 'tree-actions';
  
  // 内联编辑按钮
  const inlineEditBtn = document.createElement('button');
  inlineEditBtn.className = 'tree-action-btn inline-edit-btn';
  inlineEditBtn.textContent = '✏️';
  inlineEditBtn.title = '快速重命名';
  inlineEditBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    startInlineEdit(title, node);
  });
  actions.appendChild(inlineEditBtn);
  
  // 编辑按钮
  const editBtn = document.createElement('button');
  editBtn.className = 'tree-action-btn edit-btn';
  editBtn.textContent = '⚙️';
  editBtn.title = '详细编辑';
  editBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    try {
      addLogEntry(`编辑项目: ${node.title} (ID: ${node.id})`, 'info');
      editBookmarkItem(node);
    } catch (error) {
      addLogEntry(`编辑失败: ${error.message}`, 'error');
    }
  });
  actions.appendChild(editBtn);
  
  // 删除按钮
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'tree-action-btn delete-btn';
  deleteBtn.textContent = '🗑️';
  deleteBtn.title = '删除';
  deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    try {
      addLogEntry(`准备删除项目: ${node.title} (ID: ${node.id})`, 'info');
      deleteBookmarkItem(node);
    } catch (error) {
      addLogEntry(`删除失败: ${error.message}`, 'error');
    }
  });
  actions.appendChild(deleteBtn);
  
  nodeContent.appendChild(actions);
  nodeElement.appendChild(nodeContent);
  
  // 子节点容器（仅文件夹）
  if (!node.url && node.children) {
    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'tree-children hidden'; // 默认隐藏，但会在renderBookmarkTree中自动展开主要文件夹
    
    let childBookmarkCount = 0;
    let childFolderCount = 0;
    
    node.children.forEach(child => {
      const childElement = createTreeNode(child, level + 1);
      childrenContainer.appendChild(childElement);
      
      if (child.url) {
        childBookmarkCount++;
      } else if (child.children) {
        childFolderCount++;
      }
    });
    
    nodeElement.appendChild(childrenContainer);
    
    // 记录文件夹内容统计
    if (level <= 2) { // 只记录前两级的详细信息
      addLogEntry(`文件夹"${node.title}"包含: ${childBookmarkCount}个书签, ${childFolderCount}个子文件夹`, 'info');
    }
  }
  
  return nodeElement;
}

// 计算文件夹中的书签数量
function countBookmarksInFolder(folderNode) {
  let count = 0;
  
  function countRecursive(node) {
    if (node.url) {
      count++;
    } else if (node.children) {
      node.children.forEach(countRecursive);
    }
  }
  
  if (folderNode.children) {
    folderNode.children.forEach(countRecursive);
  }
  
  return count;
}

// 切换节点展开/折叠
function toggleNodeExpansion(nodeElement, expandButton) {
  const childrenContainer = nodeElement.querySelector('.tree-children');
  if (!childrenContainer) return;
  
  const isExpanded = !childrenContainer.classList.contains('hidden');
  
  if (isExpanded) {
    childrenContainer.classList.add('hidden');
    expandButton.textContent = '▶';
  } else {
    childrenContainer.classList.remove('hidden');
    expandButton.textContent = '▼';
  }
}

// 展开/折叠所有文件夹
function expandAllFolders(expand) {
  const expandButtons = document.querySelectorAll('.tree-expand-btn');
  const childrenContainers = document.querySelectorAll('.tree-children');
  
  expandButtons.forEach(button => {
    button.textContent = expand ? '▼' : '▶';
  });
  
  childrenContainers.forEach(container => {
    if (expand) {
      container.classList.remove('hidden');
    } else {
      container.classList.add('hidden');
    }
  });
  
  addLogEntry(`${expand ? '展开' : '折叠'}了所有文件夹`, 'info');
}

// 切换书签选择状态
function toggleBookmarkSelection(nodeId, selected) {
  if (selected) {
    selectedBookmarks.add(nodeId);
  } else {
    selectedBookmarks.delete(nodeId);
  }
  
  // 更新批量操作按钮状态
  updateBatchActionButtons();
}

// 选择/取消选择所有书签
function selectAllBookmarks(select) {
  const checkboxes = document.querySelectorAll('.tree-checkbox');
  
  checkboxes.forEach(checkbox => {
    checkbox.checked = select;
    const nodeElement = checkbox.closest('.tree-node');
    const nodeId = nodeElement.dataset.nodeId;
    
    if (select) {
      selectedBookmarks.add(nodeId);
    } else {
      selectedBookmarks.delete(nodeId);
    }
  });
  
  updateBatchActionButtons();
  addLogEntry(`${select ? '选择' : '取消选择'}了所有书签`, 'info');
}

// 更新批量操作按钮状态
function updateBatchActionButtons() {
  const hasSelection = selectedBookmarks.size > 0;
  const batchButtons = document.querySelectorAll('.batch-action-btn');
  
  batchButtons.forEach(button => {
    button.disabled = !hasSelection;
  });
  
  // 更新选择计数显示
  const selectionCount = document.getElementById('selected-count');
  if (selectionCount) {
    selectionCount.textContent = `已选择 ${selectedBookmarks.size} 项`;
  }
  
  // 显示/隐藏批量操作工具栏
  const batchOperations = document.getElementById('batch-operations');
  if (batchOperations) {
    if (hasSelection) {
      batchOperations.classList.remove('hidden');
    } else {
      batchOperations.classList.add('hidden');
    }
  }
}

// 编辑书签项目
function editBookmarkItem(node) {
  currentEditingItem = node;
  
  // 填充编辑表单
  document.getElementById('edit-title').value = node.title || '';
  document.getElementById('edit-url').value = node.url || '';
  
  // 加载父文件夹选项
  loadParentFolderOptions(node.parentId);
  
  // 显示编辑模态框
  document.getElementById('edit-modal').classList.remove('hidden');
  
  addLogEntry(`开始编辑项目: ${node.title}`, 'info');
}

// 加载父文件夹选项
function loadParentFolderOptions(currentParentId) {
  const select = document.getElementById('edit-parent');
  select.innerHTML = '';
  
  // 递归添加文件夹选项
  function addFolderOptions(nodes, level = 0) {
    nodes.forEach(node => {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = '  '.repeat(level) + (node.title || '无标题文件夹');
        
        if (node.id === currentParentId) {
          option.selected = true;
        }
        
        select.appendChild(option);
        
        // 递归添加子文件夹
        addFolderOptions(node.children, level + 1);
      }
    });
  }
  
  addFolderOptions(bookmarkTreeData);
}

// 保存书签编辑
async function saveBookmarkEdit() {
  if (!currentEditingItem) return;
  
  const newTitle = document.getElementById('edit-title').value.trim();
  const newUrl = document.getElementById('edit-url').value.trim();
  const newParentId = document.getElementById('edit-parent').value;
  
  if (!newTitle) {
    showStatus('标题不能为空', 'error');
    return;
  }
  
  if (currentEditingItem.url && !newUrl) {
    showStatus('书签URL不能为空', 'error');
    return;
  }
  
  try {
    showLoading(true);
    
    // 更新书签
    const updateData = { title: newTitle };
    if (currentEditingItem.url) {
      updateData.url = newUrl;
    }
    
    await new Promise((resolve, reject) => {
      chrome.bookmarks.update(currentEditingItem.id, updateData, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
    // 如果父文件夹改变，移动书签
    if (newParentId !== currentEditingItem.parentId) {
      await new Promise((resolve, reject) => {
        chrome.bookmarks.move(currentEditingItem.id, { parentId: newParentId }, (result) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(result);
          }
        });
      });
    }
    
    addLogEntry(`成功更新项目: ${newTitle}`, 'success');
    showStatus('保存成功', 'success');
    
    // 关闭模态框并刷新树
    closeEditModal();
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error('保存编辑失败:', error);
    addLogEntry(`保存编辑失败: ${error.message}`, 'error');
    showStatus(`保存失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 关闭编辑模态框
function closeEditModal() {
  document.getElementById('edit-modal').classList.add('hidden');
  currentEditingItem = null;
}

// 删除书签项目
async function deleteBookmarkItem(node) {
  const itemType = node.url ? '书签' : '文件夹';
  
  if (!confirm(`确定要删除${itemType}"${node.title}"吗？此操作不可撤销。`)) {
    return;
  }
  
  try {
    showLoading(true);
    
    await new Promise((resolve, reject) => {
      if (node.url) {
        // 删除书签
        chrome.bookmarks.remove(node.id, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      } else {
        // 删除文件夹（包括所有子项）
        chrome.bookmarks.removeTree(node.id, () => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve();
          }
        });
      }
    });
    
    addLogEntry(`成功删除${itemType}: ${node.title}`, 'success');
    showStatus(`删除${itemType}成功`, 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error(`删除${itemType}失败:`, error);
    addLogEntry(`删除${itemType}失败: ${error.message}`, 'error');
    showStatus(`删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 刷新书签管理器
async function refreshBookmarkManager() {
  try {
    await loadBookmarkTree();
    renderBookmarkTree();
    addLogEntry('书签管理器已刷新', 'info');
  } catch (error) {
    addLogEntry(`刷新书签管理器失败: ${error.message}`, 'error');
  }
}

// 创建新文件夹
async function createNewFolder() {
  const folderName = prompt('请输入文件夹名称:');
  if (!folderName || !folderName.trim()) {
    return;
  }
  
  try {
    showLoading(true);
    
    // 默认在"其他书签"文件夹中创建
    const parentId = '2'; // 其他书签文件夹ID
    
    await new Promise((resolve, reject) => {
      chrome.bookmarks.create({
        parentId: parentId,
        title: folderName.trim()
      }, (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(result);
        }
      });
    });
    
    addLogEntry(`成功创建文件夹: ${folderName}`, 'success');
    showStatus('文件夹创建成功', 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    console.error('创建文件夹失败:', error);
    addLogEntry(`创建文件夹失败: ${error.message}`, 'error');
    showStatus(`创建失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// ======== 批量操作功能 ========

// 批量删除项目
async function batchDeleteItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要删除的项目', 'warning');
    return;
  }
  
  if (!confirm(`确定要删除选中的 ${selectedBookmarks.size} 个项目吗？此操作不可撤销。`)) {
    return;
  }
  
  try {
    showLoading(true);
    addLogEntry(`开始批量删除 ${selectedBookmarks.size} 个项目...`, 'info');
    
    let deletedCount = 0;
    const selectedArray = Array.from(selectedBookmarks);
    
    for (const nodeId of selectedArray) {
      try {
        // 查找节点信息
        const node = findNodeById(nodeId);
        
        await new Promise((resolve, reject) => {
          if (node && node.url) {
            // 删除书签
            chrome.bookmarks.remove(nodeId, () => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve();
              }
            });
          } else {
            // 删除文件夹
            chrome.bookmarks.removeTree(nodeId, () => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve();
              }
            });
          }
        });
        
        deletedCount++;
        selectedBookmarks.delete(nodeId);
        
      } catch (error) {
        addLogEntry(`删除项目 ${nodeId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`批量删除完成，成功删除 ${deletedCount} 个项目`, 'success');
    showStatus(`批量删除完成，成功删除 ${deletedCount} 个项目`, 'success');
    
    // 刷新书签管理器
    await refreshBookmarkManager();
    
  } catch (error) {
    addLogEntry(`批量删除失败: ${error.message}`, 'error');
    showStatus(`批量删除失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 批量移动项目
function batchMoveItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要移动的项目', 'warning');
    return;
  }
  
  // 加载目标文件夹选项
  loadMoveTargetFolders();
  
  // 显示移动模态框
  document.getElementById('move-modal').classList.remove('hidden');
  
  addLogEntry(`准备批量移动 ${selectedBookmarks.size} 个项目`, 'info');
}

// 加载移动目标文件夹
function loadMoveTargetFolders() {
  const select = document.getElementById('target-folder');
  select.innerHTML = '';
  
  // 递归添加文件夹选项
  function addFolderOptions(nodes, level = 0) {
    nodes.forEach(node => {
      if (!node.url && node.children) {
        // 这是一个文件夹
        const option = document.createElement('option');
        option.value = node.id;
        option.textContent = '  '.repeat(level) + (node.title || '无标题文件夹');
        select.appendChild(option);
        
        // 递归添加子文件夹
        addFolderOptions(node.children, level + 1);
      }
    });
  }
  
  addFolderOptions(bookmarkTreeData);
}

// 确认批量移动
async function confirmMoveItems() {
  const targetFolderId = document.getElementById('target-folder').value;
  
  if (!targetFolderId) {
    showStatus('请选择目标文件夹', 'warning');
    return;
  }
  
  try {
    showLoading(true);
    addLogEntry(`开始批量移动 ${selectedBookmarks.size} 个项目到目标文件夹...`, 'info');
    
    let movedCount = 0;
    const selectedArray = Array.from(selectedBookmarks);
    
    for (const nodeId of selectedArray) {
      try {
        await new Promise((resolve, reject) => {
          chrome.bookmarks.move(nodeId, { parentId: targetFolderId }, (result) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(result);
            }
          });
        });
        
        movedCount++;
        
      } catch (error) {
        addLogEntry(`移动项目 ${nodeId} 失败: ${error.message}`, 'error');
      }
    }
    
    addLogEntry(`批量移动完成，成功移动 ${movedCount} 个项目`, 'success');
    showStatus(`批量移动完成，成功移动 ${movedCount} 个项目`, 'success');
    
    // 关闭模态框并刷新
    closeMoveModal();
    await refreshBookmarkManager();
    
  } catch (error) {
    addLogEntry(`批量移动失败: ${error.message}`, 'error');
    showStatus(`批量移动失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 关闭移动模态框
function closeMoveModal() {
  document.getElementById('move-modal').classList.add('hidden');
}

// 批量导出项目
function batchExportItems() {
  if (selectedBookmarks.size === 0) {
    showStatus('请先选择要导出的项目', 'warning');
    return;
  }
  
  try {
    const exportData = [];
    const selectedArray = Array.from(selectedBookmarks);
    
    selectedArray.forEach(nodeId => {
      const node = findNodeById(nodeId);
      if (node) {
        exportData.push({
          id: node.id,
          title: node.title,
          url: node.url,
          parentId: node.parentId,
          type: node.url ? 'bookmark' : 'folder'
        });
      }
    });
    
    // 创建CSV内容
    let csvContent = '类型,标题,URL,ID,父文件夹ID\n';
    exportData.forEach(item => {
      const type = item.type === 'bookmark' ? '书签' : '文件夹';
      const title = `"${(item.title || '').replace(/"/g, '""')}"`;
      const url = `"${(item.url || '').replace(/"/g, '""')}"`;
      csvContent += `${type},${title},${url},${item.id},${item.parentId}\n`;
    });
    
    // 下载文件
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    const fileName = `选中书签_${new Date().toISOString().slice(0, 10)}.csv`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`成功导出 ${exportData.length} 个选中项目`, 'success');
    showStatus(`导出成功: ${fileName}`, 'success');
    
  } catch (error) {
    addLogEntry(`批量导出失败: ${error.message}`, 'error');
    showStatus(`导出失败: ${error.message}`, 'error');
  }
}

// 查找节点by ID
function findNodeById(nodeId) {
  function searchNode(nodes) {
    if (!nodes || !Array.isArray(nodes)) {
      return null;
    }
    
    for (const node of nodes) {
      if (node.id === nodeId) {
        addLogEntry(`找到节点: ${node.title} (ID: ${node.id})`, 'info');
        return node;
      }
      if (node.children && Array.isArray(node.children)) {
        const found = searchNode(node.children);
        if (found) return found;
      }
    }
    return null;
  }
  
  try {
    const result = searchNode(bookmarkTreeData);
    if (!result) {
      addLogEntry(`警告: 未找到ID为 ${nodeId} 的节点`, 'warning');
    }
    return result;
  } catch (error) {
    addLogEntry(`查找节点时出错: ${error.message}`, 'error');
    return null;
  }
}

// ======== 导入导出功能 ========

// 导入书签
function importBookmarks() {
  // 触发文件选择
  document.getElementById('bookmark-file-input').click();
}

// 处理文件导入
async function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  addLogEntry(`开始导入文件: ${file.name}`, 'info');
  showLoading(true);
  
  try {
    const fileContent = await readFileContent(file);
    
    if (file.name.endsWith('.json')) {
      await importJsonBookmarks(fileContent);
    } else if (file.name.endsWith('.html')) {
      await importHtmlBookmarks(fileContent);
    } else {
      throw new Error('不支持的文件格式，请选择JSON或HTML文件');
    }
    
  } catch (error) {
    addLogEntry(`导入文件失败: ${error.message}`, 'error');
    showStatus(`导入失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
    // 清空文件输入
    event.target.value = '';
  }
}

// 读取文件内容
function readFileContent(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.onerror = () => reject(new Error('文件读取失败'));
    reader.readAsText(file, 'utf-8');
  });
}

// 导入JSON格式书签
async function importJsonBookmarks(jsonContent) {
  try {
    const bookmarkData = JSON.parse(jsonContent);
    
    if (!Array.isArray(bookmarkData)) {
      throw new Error('JSON格式不正确，应为书签数组');
    }
    
    let importedCount = 0;
    const targetFolderId = '2'; // 其他书签文件夹
    
    for (const bookmark of bookmarkData) {
      if (bookmark.url && bookmark.title) {
        try {
          await new Promise((resolve, reject) => {
            chrome.bookmarks.create({
              parentId: targetFolderId,
              title: bookmark.title,
              url: bookmark.url
            }, (result) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve(result);
              }
            });
          });
          
          importedCount++;
        } catch (error) {
          addLogEntry(`导入书签"${bookmark.title}"失败: ${error.message}`, 'warning');
        }
      }
    }
    
    addLogEntry(`JSON导入完成，成功导入 ${importedCount} 个书签`, 'success');
    showStatus(`导入成功: ${importedCount} 个书签`, 'success');
    
    // 刷新书签管理器
    if (document.getElementById('bookmark-manager-container').classList.contains('hidden') === false) {
      await refreshBookmarkManager();
    }
    
  } catch (error) {
    throw new Error(`JSON解析失败: ${error.message}`);
  }
}

// 导入HTML格式书签
async function importHtmlBookmarks(htmlContent) {
  try {
    // 创建临时DOM来解析HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    const bookmarkLinks = doc.querySelectorAll('a[href]');
    let importedCount = 0;
    const targetFolderId = '2'; // 其他书签文件夹
    
    for (const link of bookmarkLinks) {
      const url = link.getAttribute('href');
      const title = link.textContent.trim();
      
      if (url && title) {
        try {
          await new Promise((resolve, reject) => {
            chrome.bookmarks.create({
              parentId: targetFolderId,
              title: title,
              url: url
            }, (result) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve(result);
              }
            });
          });
          
          importedCount++;
        } catch (error) {
          addLogEntry(`导入书签"${title}"失败: ${error.message}`, 'warning');
        }
      }
    }
    
    addLogEntry(`HTML导入完成，成功导入 ${importedCount} 个书签`, 'success');
    showStatus(`导入成功: ${importedCount} 个书签`, 'success');
    
    // 刷新书签管理器
    if (document.getElementById('bookmark-manager-container').classList.contains('hidden') === false) {
      await refreshBookmarkManager();
    }
    
  } catch (error) {
    throw new Error(`HTML解析失败: ${error.message}`);
  }
}

// 备份书签
async function backupBookmarks() {
  addLogEntry('开始备份所有书签...', 'info');
  showLoading(true);
  
  try {
    // 获取所有书签
    const allBookmarks = await getAllBookmarks();
    
    // 创建备份数据
    const backupData = {
      timestamp: new Date().toISOString(),
      version: '1.0',
      bookmarkCount: allBookmarks.length,
      bookmarks: allBookmarks
    };
    
    // 创建JSON文件
    const jsonContent = JSON.stringify(backupData, null, 2);
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    const fileName = `书签备份_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    addLogEntry(`备份完成，共备份 ${allBookmarks.length} 个书签`, 'success');
    showStatus(`备份成功: ${fileName}`, 'success');
    
  } catch (error) {
    addLogEntry(`备份失败: ${error.message}`, 'error');
    showStatus(`备份失败: ${error.message}`, 'error');
  } finally {
    showLoading(false);
  }
}

// 将关键函数暴露到全局作用域，以便onclick事件处理器可以访问
window.editBookmarkItem = editBookmarkItem;
window.deleteBookmarkItem = deleteBookmarkItem;
window.toggleNodeExpansion = toggleNodeExpansion;
window.toggleBookmarkSelection = toggleBookmarkSelection;

// 添加调试和诊断功能
window.debugBookmarkManager = function() {
  console.log('=== 书签管理器调试信息 ===');
  
  // 1. 检查Chrome API
  console.log('1. Chrome API检查:');
  console.log('- chrome:', !!chrome);
  console.log('- chrome.bookmarks:', !!chrome?.bookmarks);
  console.log('- chrome.bookmarks.getTree:', typeof chrome?.bookmarks?.getTree);
  
  // 2. 检查DOM元素
  console.log('2. DOM元素检查:');
  const managerContainer = document.getElementById('bookmark-manager-container');
  const treeContainer = document.getElementById('bookmark-tree');
  console.log('- bookmark-manager-container:', !!managerContainer, managerContainer?.classList?.contains('hidden') ? '隐藏' : '显示');
  console.log('- bookmark-tree:', !!treeContainer);
  
  // 3. 检查数据状态
  console.log('3. 数据状态检查:');
  console.log('- bookmarkTreeData:', !!bookmarkTreeData, bookmarkTreeData?.length || 0);
  console.log('- selectedBookmarks:', selectedBookmarks?.size || 0);
  
  // 4. 尝试获取书签数据
  console.log('4. 尝试获取书签数据:');
  if (chrome?.bookmarks?.getTree) {
    chrome.bookmarks.getTree((nodes) => {
      if (chrome.runtime.lastError) {
        console.error('获取书签失败:', chrome.runtime.lastError);
      } else {
        console.log('成功获取书签树:', nodes);
        const stats = analyzeBookmarkTree(nodes);
        console.log('书签统计:', stats);
      }
    });
  }
  
  // 5. 检查渲染的节点
  console.log('5. 渲染节点检查:');
  const renderedNodes = document.querySelectorAll('.tree-node');
  console.log('- 渲染的节点数:', renderedNodes.length);
  
  if (renderedNodes.length > 0) {
    console.log('- 前5个节点的详情:');
    Array.from(renderedNodes).slice(0, 5).forEach((node, index) => {
      const title = node.querySelector('.tree-title')?.textContent;
      const nodeId = node.dataset.nodeId;
      console.log(`  ${index + 1}. "${title}" (ID: ${nodeId})`);
    });
  }
  
  // 6. 检查事件绑定
  console.log('6. 事件绑定检查:');
  const editButtons = document.querySelectorAll('.edit-btn');
  const deleteButtons = document.querySelectorAll('.delete-btn');
  console.log('- 编辑按钮数:', editButtons.length);
  console.log('- 删除按钮数:', deleteButtons.length);
  
  // 7. 检查扩展权限
  console.log('7. 扩展权限检查:');
  chrome.permissions?.getAll?.((permissions) => {
    console.log('- 当前权限:', permissions);
  });
  
  console.log('=== 调试信息结束 ===');
  
  return {
    chromeApi: !!chrome?.bookmarks,
    domElements: {
      managerContainer: !!managerContainer,
      treeContainer: !!treeContainer
    },
    data: {
      bookmarkTreeData: !!bookmarkTreeData,
      selectedBookmarks: selectedBookmarks?.size || 0
    },
    renderedNodes: renderedNodes.length
  };
};

// 自动书签管理器修复函数
window.fixBookmarkManager = async function() {
  console.log('开始自动修复书签管理器...');
  addLogEntry('启动书签管理器自动修复程序...', 'info');
  
  try {
    // 1. 重新加载数据
    addLogEntry('步骤1: 重新加载书签数据...', 'info');
    await loadBookmarkTree();
    
    // 2. 重新渲染界面
    addLogEntry('步骤2: 重新渲染界面...', 'info');
    renderBookmarkTree();
    
    // 3. 自动展开主要文件夹
    addLogEntry('步骤3: 自动展开主要文件夹...', 'info');
    setTimeout(() => {
      expandFirstLevelFolders();
      expandAllFolders(true); // 展开所有文件夹以确保用户能看到所有书签
    }, 500);
    
    // 4. 验证修复结果
    setTimeout(() => {
      const renderedNodes = document.querySelectorAll('.tree-node');
      const visibleNodes = document.querySelectorAll('.tree-node:not(.tree-children.hidden .tree-node)');
      
      addLogEntry(`修复完成! 共渲染 ${renderedNodes.length} 个节点，其中 ${visibleNodes.length} 个可见`, 'success');
      
      if (renderedNodes.length === 0) {
        addLogEntry('警告: 没有渲染任何节点，可能存在数据问题', 'warning');
      }
    }, 1000);
    
  } catch (error) {
    addLogEntry(`自动修复失败: ${error.message}`, 'error');
    throw error;
  }
};

console.log('书签管理器调试功能已加载。使用 debugBookmarkManager() 查看调试信息，使用 fixBookmarkManager() 尝试自动修复。');